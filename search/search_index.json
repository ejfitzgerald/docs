{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the Fetch.AI documentation. Getting Started Build and install the Fetch.AI Ledger constellation, etch vm, and all the libraries you need. Get hold of the Fetch.AI Python Ledger API for smart contract creation. Spin up the Fetch.AI Open Economic Framework. The Fetch.AI Ledger Understand the inner workings of the Fetch.AI Ledger. Open Economic Framework Learn how to create decentralised autonomous agents and interface them to the digital world. Learn how to negotiate with other autonomous agents and get things done. etch Language Guide Learn how to code in etch , the Turing complete scripting language for smart contracts running on the Fetch.AI Ledger. Smart Contracts Smart contracts written in etch run with the Python Ledger API. This section has everything you need to know about running smart contracts on the Fetch.AI Ledger. Tutorials Here you will find a growing list of tutorials on building smart contracts. Feel free to submit your own tutorial or demo.","title":"Welcome to the <a href=\"https://fetch.ai/\" target=_blank>Fetch.AI</a> documentation."},{"location":"#welcome-to-the-fetchai-documentation","text":"Getting Started Build and install the Fetch.AI Ledger constellation, etch vm, and all the libraries you need. Get hold of the Fetch.AI Python Ledger API for smart contract creation. Spin up the Fetch.AI Open Economic Framework. The Fetch.AI Ledger Understand the inner workings of the Fetch.AI Ledger. Open Economic Framework Learn how to create decentralised autonomous agents and interface them to the digital world. Learn how to negotiate with other autonomous agents and get things done. etch Language Guide Learn how to code in etch , the Turing complete scripting language for smart contracts running on the Fetch.AI Ledger. Smart Contracts Smart contracts written in etch run with the Python Ledger API. This section has everything you need to know about running smart contracts on the Fetch.AI Ledger. Tutorials Here you will find a growing list of tutorials on building smart contracts. Feel free to submit your own tutorial or demo.","title":"Welcome to the Fetch.AI"},{"location":"playground/","text":"The most basic introduction etch is a high-level, statically-typed programming language designed for creating smart contracts on the Fetch.AI constellation ledger. Unlike similar languages, etch allows developers to code advanced compute-intensive logic for high performance scenarios such as machine learning and AI. Check out the Fetch.AI etch language guide here . But for the quickest start... Hello World function main () for ( i in 0 : 5 ) printLn ( \"Hello World, how are you? (\" + toString ( i ) + \")\" ); endfor endfunction Copy/paste the code into the window on the left. Click run and you will see the results in the right. The main function is where execution starts. The for loop prints out \u201cHello world\u201d along with a number representing the loop index. Flow control and looping As well as for , etch also supports while : function main () var i : Int32 = 0 ; while ( i < 10 ) printLn ( toString ( i )); i ++ ; endwhile endfunction for and while support continue and break which skip an iteration or break out of the loop respectively. Note that we support ++ for increment. We also support operators for += , -- , -= , etc. Also observe that we declare the variable i as an Int32 a 32 bit integer type. etch has many built-in types, and they include: Float32 , Float64 , Int32 , Int64 , UInt32 , UInt64 , Bool , String , Array , and more. For flow control, use the if/else/elseif/endif structure: function main () var colourIndex = 15 ; var insertCharacter : String = \" \" ; if ( colourIndex < 2 ) insertCharacter = \" \" ; elseif ( colourIndex < 8 ) insertCharacter = \"'\" ; elseif ( colourIndex < 20 ) insertCharacter = \"*\" ; else insertCharacter = \"@\" ; endif printLn ( insertCharacter ); endfunction Check out the guide for further details, including information on complex data structures and smart contract creation.","title":"Playground"},{"location":"playground/#the-most-basic-introduction","text":"etch is a high-level, statically-typed programming language designed for creating smart contracts on the Fetch.AI constellation ledger. Unlike similar languages, etch allows developers to code advanced compute-intensive logic for high performance scenarios such as machine learning and AI. Check out the Fetch.AI etch language guide here . But for the quickest start...","title":"The most basic introduction"},{"location":"playground/#hello-world","text":"function main () for ( i in 0 : 5 ) printLn ( \"Hello World, how are you? (\" + toString ( i ) + \")\" ); endfor endfunction Copy/paste the code into the window on the left. Click run and you will see the results in the right. The main function is where execution starts. The for loop prints out \u201cHello world\u201d along with a number representing the loop index.","title":"Hello World"},{"location":"playground/#flow-control-and-looping","text":"As well as for , etch also supports while : function main () var i : Int32 = 0 ; while ( i < 10 ) printLn ( toString ( i )); i ++ ; endwhile endfunction for and while support continue and break which skip an iteration or break out of the loop respectively. Note that we support ++ for increment. We also support operators for += , -- , -= , etc. Also observe that we declare the variable i as an Int32 a 32 bit integer type. etch has many built-in types, and they include: Float32 , Float64 , Int32 , Int64 , UInt32 , UInt64 , Bool , String , Array , and more. For flow control, use the if/else/elseif/endif structure: function main () var colourIndex = 15 ; var insertCharacter : String = \" \" ; if ( colourIndex < 2 ) insertCharacter = \" \" ; elseif ( colourIndex < 8 ) insertCharacter = \"'\" ; elseif ( colourIndex < 20 ) insertCharacter = \"*\" ; else insertCharacter = \"@\" ; endif printLn ( insertCharacter ); endfunction Check out the guide for further details, including information on complex data structures and smart contract creation.","title":"Flow control and looping"},{"location":"etch-language/","text":"Welcome to the etch language docs Your browser does not support the video tag. For news, tutorials, and the latest, visit https://community.fetch.ai . What's etch ? etch is a high-level, statically-typed programming language designed for creating smart contracts on the Fetch.AI Ledger. Unlike similar languages, etch allows developers to code advanced compute-intensive logic for high performance scenarios such as machine learning and AI. The Fetch.AI Ledger (known as Constellation) runs compiled etch bytecode that is extremely robust to ensure maximum hardware-optimised performance. The etch language imposes rigorous compilation restrictions in order to avoid unwelcome and costly runtime errors. Design and test your smart contract code with the etch VM simulator before including it in a Python Ledger API script which takes care of deployment and other details. Find out how to run smart contract code with the Python Ledger API here . Please note: The etch language and the etch language guide are work in progress so some areas of the language remain incomplete for now. Please try out as much code as you like and send us your examples. Let us know if you have any problems.","title":"What's etch?"},{"location":"etch-language/addresses/","text":"Address The Address data structure formats multiple cryptographic public key types. Currently, Address public key types start out as uncompressed ECDSA secp256k1_ 64 byte binary arrays. An Address is generated by hashing the raw bytes of the public key and appending a 4 byte checksum. The checksum comes from the hash of the first 4 bytes of the Address . The result is Base58 encoded. You can generate test addresses with the the ledger-api-py (Python SDK). And in etch , you can instantiate an Address like this: function main () var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); endfunction SHA256 etch currently supports the SHA256 encryption algorithm. Find out more here . Verification The Address type has a function signedTx() which allows you to verify the signature. It returns a boolean. This is only valid in an @action function, else it will return false. function main () var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var verified : Bool ; verified = account . signedTx (); printLn ( toString ( verified )); endfunction The above code always prints false when it is not contained within an @action function. The Address type will eventually support all asymmetric cryptographic types and, more importantly, will be quantum computing ready.","title":"Address"},{"location":"etch-language/addresses/#sha256","text":"etch currently supports the SHA256 encryption algorithm. Find out more here .","title":"SHA256"},{"location":"etch-language/addresses/#verification","text":"The Address type has a function signedTx() which allows you to verify the signature. It returns a boolean. This is only valid in an @action function, else it will return false. function main () var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var verified : Bool ; verified = account . signedTx (); printLn ( toString ( verified )); endfunction The above code always prints false when it is not contained within an @action function. The Address type will eventually support all asymmetric cryptographic types and, more importantly, will be quantum computing ready.","title":"Verification"},{"location":"etch-language/arrays/","text":"Arrays One dimensional arrays Declare, access by index, and iterate over an array like this: function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; // print the array printLn ( myArray ); // print a single element of the array printLn ( toString ( myArray [ 3 ])); // print elements ascending for ( i in 0 : myArray . count ()) printLn ( toString ( myArray [ i ])); endfor endfunction Two dimensional arrays Declare a 4x4 two dimensional array like this: function main () // build a 4x4 grid var grid = Array < Array < Int32 > > ( 4 ); for ( row in 0 : grid . count ()) grid [ row ] = Array < Int32 > ( 4 ); endfor // initialise row and column values var count = 1 ; for ( row in 0 : grid . count ()) for ( column in 0 : grid [ row ]. count ()) grid [ row ][ column ] = count ; count += 1 ; endfor printLn ( grid [ row ]); endfor endfunction Nested arrays etch supports arrays of arrays of arrays, etc. function main () var ref_array = Array < Array < Array < String >>> ( 2 ); ref_array [ 0 ] = Array < Array < String >> ( 2 ); ref_array [ 1 ] = Array < Array < String >> ( 2 ); ref_array [ 0 ][ 0 ] = Array < String > ( 1 ); ref_array [ 0 ][ 1 ] = Array < String > ( 1 ); ref_array [ 1 ][ 0 ] = Array < String > ( 2 ); ref_array [ 1 ][ 1 ] = Array < String > ( 2 ); endfunction Array functions Count The count() function returns the number of items in a one dimensional array, or the number of arrays in a two dimensional array. Returns 0 if the array is empty. function main () var myArray = Array < Int32 > ( 2 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; printLn ( myArray . count ()); myArray . append ( 42 ); printLn ( myArray . count ()); endfunction function main () printLn ( Array < Array < UInt32 >> ( 10 ). count ()); endfunction Append The append() function adds a new type safe item to the end of a one dimensional array. function main () var myArray = Array < UInt32 > ( 2 ); myArray [ 0 ] = 1u32 ; myArray [ 1 ] = 2u32 ; myArray . append ( 42u32 ); // type safety check // myArray.append(\"hello\"); // error: unable to find matching function for 'append' printLn ( myArray ); endfunction Or an array to the end of a two dimensional array. function main () var my2dArray = Array < Array < Int32 >> ( 3 ); var count = 1 ; for ( i in 0 : my2dArray . count ()) my2dArray [ i ] = Array < Int32 > ( 3 ); for ( j in 0 : my2dArray . count ()) my2dArray [ i ][ j ] = count ; count += 1 ; endfor printLn ( my2dArray [ i ]); endfor printLn ( \" \" ); my2dArray . append ( Array < Int32 > ( 8 )); my2dArray [ 1 ]. append ( 42 ); for ( k in 0 : my2dArray . count ()) printLn ( my2dArray [ k ]); endfor endfunction Extend Use extend() to append the contents of one array to another in order of insertion. Array types must be the same. function main () var data1 = Array < Int32 > ( 3 ); data1 [ 0 ] = 1 ; data1 [ 1 ] = 2 ; data1 [ 2 ] = 3 ; printLn ( data1 ); var data2 = Array < Int32 > ( 2 ); data2 [ 0 ] = 5 ; data2 [ 1 ] = 4 ; data1 . extend ( data2 ); printLn ( data1 ); endfunction Pop back and pop front The popBack() function removes and returns the last item from a one dimensional array, or the last array from a two dimensional array. The popFront() function removes and returns the first item or array, or the first array from a two dimensional array. Fails if the array is empty. function main () var myArray = Array < Int32 > ( 3 ); myArray [ 0 ] = 10 ; myArray [ 1 ] = 20 ; myArray [ 2 ] = 30 ; printLn ( myArray ); var backItem = myArray . popBack (); var frontItem = myArray . popFront (); printLn (( toString ( backItem )) + \" removed from the end of myArray\" ); printLn (( toString ( frontItem )) + \" removed from the start of myArray\" ); printLn ( myArray ); endfunction function main () //create a 3 by 3 array var my2dArray = Array < Array < Int32 >> ( 3 ); var count = 1 ; for ( i in 0 : my2dArray . count ()) my2dArray [ i ] = Array < Int32 > ( 3 ); for ( j in 0 : my2dArray [ i ]. count ()) my2dArray [ i ][ j ] = count ; count += 1 ; endfor printLn ( my2dArray [ i ]); endfor printLn ( \"Remove back and front arrays\" ); var backArray = my2dArray . popBack (); printLn ( backArray ); var frontArray = my2dArray . popFront (); printLn ( frontArray ); printLn ( \"Left with\" ); for ( row in 0 : my2dArray . count ()) printLn ( my2dArray [ row ]); endfor endfunction Pop back and front with n Use popBack(n) to remove the last n items from a one dimensional array, or the last n arrays from a two dimensional array, and return them as an array(s). Use popFront(n) to remove and return the first n items or arrays. n must be a non-negative integer. Returns an array. Fails if n is negative or n is greater than the number of items or arrays. Returns an empty array if n equals 0, leaving the original array unchanged. function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 10 ; myArray [ 1 ] = 20 ; myArray [ 2 ] = 30 ; myArray [ 3 ] = 40 ; myArray [ 4 ] = 50 ; printLn ( myArray ); var backItems = myArray . popBack ( 2 ); var frontItems = myArray . popFront ( 1 ); printLn ( \"n=2 items removed from end: \" ); printLn ( backItems ); printLn ( \"n=1 items removed from start: \" ); printLn ( frontItems ); printLn ( \"Remaining array: \" ); printLn ( myArray ); endfunction function main () var my2dArray = Array < Array < Int32 >> ( 5 ); var count = 11 ; for ( i in 0 : my2dArray . count ()) my2dArray [ i ] = Array < Int32 > ( 5 ); for ( j in 0 : my2dArray [ i ]. count ()) my2dArray [ i ][ j ] = count ; count += 1 ; endfor printLn ( my2dArray [ i ]); endfor var backArray = my2dArray . popBack ( 2 ); var frontArray = my2dArray . popFront ( 2 ); printLn ( \"n=2 removed back arrays: \" ); for ( k in 0 : 1 ) printLn ( backArray [ k ]); endfor printLn ( \"n=2 removed front arrays: \" ); for ( l in 0 : 1 ) printLn ( frontArray [ l ]); endfor printLn ( \"Remaining array(s) : \") ; for ( m in 0 : 0 ) printLn ( my2dArray [ m ]); endfor endfunction Reverse The reverse() function reverses the order of items in a one dimensional array, or the order of arrays in a two dimensional array. function main () var myArray = Array < Int32 > ( 3 ); myArray [ 0 ] = 10 ; myArray [ 1 ] = 20 ; myArray [ 2 ] = 30 ; printLn ( myArray ); myArray . reverse (); printLn ( myArray ); endfunction function main () var my2dArray = Array < Array < Int32 >> ( 5 ); var count = 101 ; for ( i in 0 : my2dArray . count ()) my2dArray [ i ] = Array < Int32 > ( 5 ); for ( j in 0 : my2dArray [ i ]. count ()) my2dArray [ i ][ j ] = count ; count += 1 ; endfor printLn ( my2dArray [ i ]); endfor my2dArray . reverse (); printLn ( \"Reversed: \" ); for ( k in 0 : 4 ) printLn ( my2dArray [ k ]); endfor endfunction Erase Remove an element from an array with the erase() function. function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; printLn ( myArray ); myArray . erase ( 2 ); printLn ( myArray ); endfunction","title":"Arrays"},{"location":"etch-language/arrays/#one-dimensional-arrays","text":"Declare, access by index, and iterate over an array like this: function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; // print the array printLn ( myArray ); // print a single element of the array printLn ( toString ( myArray [ 3 ])); // print elements ascending for ( i in 0 : myArray . count ()) printLn ( toString ( myArray [ i ])); endfor endfunction","title":"One dimensional arrays"},{"location":"etch-language/arrays/#two-dimensional-arrays","text":"Declare a 4x4 two dimensional array like this: function main () // build a 4x4 grid var grid = Array < Array < Int32 > > ( 4 ); for ( row in 0 : grid . count ()) grid [ row ] = Array < Int32 > ( 4 ); endfor // initialise row and column values var count = 1 ; for ( row in 0 : grid . count ()) for ( column in 0 : grid [ row ]. count ()) grid [ row ][ column ] = count ; count += 1 ; endfor printLn ( grid [ row ]); endfor endfunction","title":"Two dimensional arrays"},{"location":"etch-language/arrays/#nested-arrays","text":"etch supports arrays of arrays of arrays, etc. function main () var ref_array = Array < Array < Array < String >>> ( 2 ); ref_array [ 0 ] = Array < Array < String >> ( 2 ); ref_array [ 1 ] = Array < Array < String >> ( 2 ); ref_array [ 0 ][ 0 ] = Array < String > ( 1 ); ref_array [ 0 ][ 1 ] = Array < String > ( 1 ); ref_array [ 1 ][ 0 ] = Array < String > ( 2 ); ref_array [ 1 ][ 1 ] = Array < String > ( 2 ); endfunction","title":"Nested arrays"},{"location":"etch-language/arrays/#array-functions","text":"","title":"Array functions"},{"location":"etch-language/arrays/#count","text":"The count() function returns the number of items in a one dimensional array, or the number of arrays in a two dimensional array. Returns 0 if the array is empty. function main () var myArray = Array < Int32 > ( 2 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; printLn ( myArray . count ()); myArray . append ( 42 ); printLn ( myArray . count ()); endfunction function main () printLn ( Array < Array < UInt32 >> ( 10 ). count ()); endfunction","title":"Count"},{"location":"etch-language/arrays/#append","text":"The append() function adds a new type safe item to the end of a one dimensional array. function main () var myArray = Array < UInt32 > ( 2 ); myArray [ 0 ] = 1u32 ; myArray [ 1 ] = 2u32 ; myArray . append ( 42u32 ); // type safety check // myArray.append(\"hello\"); // error: unable to find matching function for 'append' printLn ( myArray ); endfunction Or an array to the end of a two dimensional array. function main () var my2dArray = Array < Array < Int32 >> ( 3 ); var count = 1 ; for ( i in 0 : my2dArray . count ()) my2dArray [ i ] = Array < Int32 > ( 3 ); for ( j in 0 : my2dArray . count ()) my2dArray [ i ][ j ] = count ; count += 1 ; endfor printLn ( my2dArray [ i ]); endfor printLn ( \" \" ); my2dArray . append ( Array < Int32 > ( 8 )); my2dArray [ 1 ]. append ( 42 ); for ( k in 0 : my2dArray . count ()) printLn ( my2dArray [ k ]); endfor endfunction","title":"Append"},{"location":"etch-language/arrays/#extend","text":"Use extend() to append the contents of one array to another in order of insertion. Array types must be the same. function main () var data1 = Array < Int32 > ( 3 ); data1 [ 0 ] = 1 ; data1 [ 1 ] = 2 ; data1 [ 2 ] = 3 ; printLn ( data1 ); var data2 = Array < Int32 > ( 2 ); data2 [ 0 ] = 5 ; data2 [ 1 ] = 4 ; data1 . extend ( data2 ); printLn ( data1 ); endfunction","title":"Extend"},{"location":"etch-language/arrays/#pop-back-and-pop-front","text":"The popBack() function removes and returns the last item from a one dimensional array, or the last array from a two dimensional array. The popFront() function removes and returns the first item or array, or the first array from a two dimensional array. Fails if the array is empty. function main () var myArray = Array < Int32 > ( 3 ); myArray [ 0 ] = 10 ; myArray [ 1 ] = 20 ; myArray [ 2 ] = 30 ; printLn ( myArray ); var backItem = myArray . popBack (); var frontItem = myArray . popFront (); printLn (( toString ( backItem )) + \" removed from the end of myArray\" ); printLn (( toString ( frontItem )) + \" removed from the start of myArray\" ); printLn ( myArray ); endfunction function main () //create a 3 by 3 array var my2dArray = Array < Array < Int32 >> ( 3 ); var count = 1 ; for ( i in 0 : my2dArray . count ()) my2dArray [ i ] = Array < Int32 > ( 3 ); for ( j in 0 : my2dArray [ i ]. count ()) my2dArray [ i ][ j ] = count ; count += 1 ; endfor printLn ( my2dArray [ i ]); endfor printLn ( \"Remove back and front arrays\" ); var backArray = my2dArray . popBack (); printLn ( backArray ); var frontArray = my2dArray . popFront (); printLn ( frontArray ); printLn ( \"Left with\" ); for ( row in 0 : my2dArray . count ()) printLn ( my2dArray [ row ]); endfor endfunction","title":"Pop back and pop front"},{"location":"etch-language/arrays/#pop-back-and-front-with-n","text":"Use popBack(n) to remove the last n items from a one dimensional array, or the last n arrays from a two dimensional array, and return them as an array(s). Use popFront(n) to remove and return the first n items or arrays. n must be a non-negative integer. Returns an array. Fails if n is negative or n is greater than the number of items or arrays. Returns an empty array if n equals 0, leaving the original array unchanged. function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 10 ; myArray [ 1 ] = 20 ; myArray [ 2 ] = 30 ; myArray [ 3 ] = 40 ; myArray [ 4 ] = 50 ; printLn ( myArray ); var backItems = myArray . popBack ( 2 ); var frontItems = myArray . popFront ( 1 ); printLn ( \"n=2 items removed from end: \" ); printLn ( backItems ); printLn ( \"n=1 items removed from start: \" ); printLn ( frontItems ); printLn ( \"Remaining array: \" ); printLn ( myArray ); endfunction function main () var my2dArray = Array < Array < Int32 >> ( 5 ); var count = 11 ; for ( i in 0 : my2dArray . count ()) my2dArray [ i ] = Array < Int32 > ( 5 ); for ( j in 0 : my2dArray [ i ]. count ()) my2dArray [ i ][ j ] = count ; count += 1 ; endfor printLn ( my2dArray [ i ]); endfor var backArray = my2dArray . popBack ( 2 ); var frontArray = my2dArray . popFront ( 2 ); printLn ( \"n=2 removed back arrays: \" ); for ( k in 0 : 1 ) printLn ( backArray [ k ]); endfor printLn ( \"n=2 removed front arrays: \" ); for ( l in 0 : 1 ) printLn ( frontArray [ l ]); endfor printLn ( \"Remaining array(s) : \") ; for ( m in 0 : 0 ) printLn ( my2dArray [ m ]); endfor endfunction","title":"Pop back and front with n"},{"location":"etch-language/arrays/#reverse","text":"The reverse() function reverses the order of items in a one dimensional array, or the order of arrays in a two dimensional array. function main () var myArray = Array < Int32 > ( 3 ); myArray [ 0 ] = 10 ; myArray [ 1 ] = 20 ; myArray [ 2 ] = 30 ; printLn ( myArray ); myArray . reverse (); printLn ( myArray ); endfunction function main () var my2dArray = Array < Array < Int32 >> ( 5 ); var count = 101 ; for ( i in 0 : my2dArray . count ()) my2dArray [ i ] = Array < Int32 > ( 5 ); for ( j in 0 : my2dArray [ i ]. count ()) my2dArray [ i ][ j ] = count ; count += 1 ; endfor printLn ( my2dArray [ i ]); endfor my2dArray . reverse (); printLn ( \"Reversed: \" ); for ( k in 0 : 4 ) printLn ( my2dArray [ k ]); endfor endfunction","title":"Reverse"},{"location":"etch-language/arrays/#erase","text":"Remove an element from an array with the erase() function. function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; printLn ( myArray ); myArray . erase ( 2 ); printLn ( myArray ); endfunction","title":"Erase"},{"location":"etch-language/control-flow/","text":"Control flow Tip Make sure to declare the end of the function and construct. if-else function main () var x = 2 ; var y = 2 ; if ( x == y ) printLn ( \"They are equal.\" ); elseif ( x > y ) printLn ( \"x is more than y.\" ); else if ( x > y ) printLn ( \"x is more than y.\" ); else printLn ( \"y is more than x.\" ); endif endif endfunction You can also test more complex data types for equality. function main () var x = State < Int32 > ( \"account1\" ); var y = State < Int32 > ( \"account2\" ); x . set ( 5 ); y . set ( 8 ); if ( x . get () > y . get ()) printLn ( \"Object x is greater than object y.\" ); else printLn ( \"Object x is less than or equal to object y.\" ); endif endfunction while function main () var i = 0 ; while ( i < 10 ) printLn ( toString ( i )); i += 1 ; endwhile endfunction for function main () // ascending printLn ( \"Ascending for loop.\" ); for ( i in 0 : 5 ) printLn ( toString ( i )); endfor // stepwise ascent printLn ( \"Ascending stepwise.\" ); for ( k in 0 : 10 : 2 ) printLn ( toString ( k )); endfor endfunction break function main () for ( i in 0 : 10 ) printLn ( toString ( i )); if ( i == 5 ) break ; endif endfor endfunction continue function main () var i = 0 ; while ( i < 10 ) i += 1 ; if ( i == 5 ) continue ; endif printLn ( toString ( i )); endwhile endfunction","title":"Control flow"},{"location":"etch-language/control-flow/#if-else","text":"function main () var x = 2 ; var y = 2 ; if ( x == y ) printLn ( \"They are equal.\" ); elseif ( x > y ) printLn ( \"x is more than y.\" ); else if ( x > y ) printLn ( \"x is more than y.\" ); else printLn ( \"y is more than x.\" ); endif endif endfunction You can also test more complex data types for equality. function main () var x = State < Int32 > ( \"account1\" ); var y = State < Int32 > ( \"account2\" ); x . set ( 5 ); y . set ( 8 ); if ( x . get () > y . get ()) printLn ( \"Object x is greater than object y.\" ); else printLn ( \"Object x is less than or equal to object y.\" ); endif endfunction","title":"if-else"},{"location":"etch-language/control-flow/#while","text":"function main () var i = 0 ; while ( i < 10 ) printLn ( toString ( i )); i += 1 ; endwhile endfunction","title":"while"},{"location":"etch-language/control-flow/#for","text":"function main () // ascending printLn ( \"Ascending for loop.\" ); for ( i in 0 : 5 ) printLn ( toString ( i )); endfor // stepwise ascent printLn ( \"Ascending stepwise.\" ); for ( k in 0 : 10 : 2 ) printLn ( toString ( k )); endfor endfunction","title":"for"},{"location":"etch-language/control-flow/#break","text":"function main () for ( i in 0 : 10 ) printLn ( toString ( i )); if ( i == 5 ) break ; endif endfor endfunction","title":"break"},{"location":"etch-language/control-flow/#continue","text":"function main () var i = 0 ; while ( i < 10 ) i += 1 ; if ( i == 5 ) continue ; endif printLn ( toString ( i )); endwhile endfunction","title":"continue"},{"location":"etch-language/crypto/","text":"SHA256 The SHA256() object gives you a number of ways to generate random 32 byte hashes which are returned as a 64 digit hexadecimal number. Use update() on the SHA256() object to include String or Buffer types into the context before finalising the hash. The final() function generates the hash and returns the value. The reset() function allows you to start over with the same object. function main () // construct a SHA256 object var s = SHA256 (); // update the object with a string s . update ( \"hello\" ); // update the object with a Buffer var buffer = Buffer ( 8 ); s . update ( buffer ); // finalise the object s . final (); // reset the object s . reset (); endfunction Here's another example which builds a SHA256 hash by concatenating strings into the context object. function main () var my_string_value_1 = \"sdkjfhiuwehfesdfno ; s ; ' mADF ; LK \"; var my_string_value_2 = \"ipoiuwr8934jklnwlkj0892;m\" ; var my_string_value_3 = \"vvvowywnklhjxlmxxxxxxxxxxxxxxxxxxxxxxxxtreretrgy653wre6548\" ; // create a SHA256() context object var sha256_hasher_context = SHA256 (); // give it your strings sha256_hasher_context . update ( my_string_value_1 ); sha256_hasher_context . update ( my_string_value_2 ); sha256_hasher_context . update ( my_string_value_3 ); // finalise the context and print the hash value var hash_value_of_concatenated_strings_1_2_3 = sha256_hasher_context . final (); printLn ( \"Hash of my concatenated string 1,2,3 = \" + toString ( hash_value_of_concatenated_strings_1_2_3 )); // RESETTING context of the hasher since we want to start calculate hash from the scratch sha256_hasher_context . reset (); // more strings var my_string_value_4 = \"12345fg\" ; var my_string_value_5 = \"@!#$@#%#\" ; var my_string_value_6 = \"{}:>L$%^:c\" ; // add to context sha256_hasher_context . update ( my_string_value_4 ); sha256_hasher_context . update ( my_string_value_5 ); sha256_hasher_context . update ( my_string_value_6 ); // finalise and print the value var hash_value_of_concatenated_strings_4_5_6 = sha256_hasher_context . final (); printLn ( \"Hash of my concatenated string 4,5,6 = \" + toString ( hash_value_of_concatenated_strings_4_5_6 )); endfunction","title":"Cryptographic functions"},{"location":"etch-language/debug/","text":"Debugging tips and tricks Use printLn(toString(...)) to query variables on the command line and in the etch playground. Note In a live environment, the etch compiler will strip out printLn() statements. Compiling Our compiler is very strict. It will complain about: Unknown and unsupported symbols, operators, and indexes. Lack of types for variables and parameters. Assigning null to primitive types. Incorrect, incompatible, and uninferrable types in statements and functions. Duplicate variables, parameters, and functions. Incomparable types in boolean tests. Unmatched and unexpected beginnings, middles, and endings in selections, iterations, statements, and blocks. Incorrectly formed statements. Incorrect amount, or lack of, operands in boolean tests. break and continue statements outside while or for loops. Non-functions, unmatched functions, and functions that do not return a value. Local function definitions. Returning null or no value from functions. Attempts to construct primitives and unmatched constructors. Mismatches between type and instance functions. Member access support issues with dot operator. while , for , if , var , return , break , continue , variables, and expressions declared at topmost scope. System arguments System.Argc() and System.Argv() give access to compiler argument count and values. The following code prints the number of compiler arguments, then lists their values. function main () var message : String ; printLn ( \"System args: \" + toString ( System . Argc ())); // print the argument values for ( i in 0 : System . Argc ()) message = toString ( i ) + \" = \" + System . Argv ( i ); printLn ( message ); endfor endfunction Running the code from the command line with zero flags -- sends arguments to the etch executable. For example, run the code snippet above with zero flags -- and an example argument hello like this: ./etch sysargs-examples.etch -- hello You should see the following output: F E \u2571 etch v0 .1.0 - 30 - g557389e0 T C Copyright 2018 - 2019 ( c ) Fetch AI Ltd . H System args : 2 0 = . / etch 1 = hello etch features like this are useful for experimentation and debugging in a development environment. For example, the system arguments can load machine learning training data into a script. For smart contracts, there are flags, such as -data , which do specific things. We explain coding, compiling, contract flags, and all about etch smart contracts here .","title":"Debugging"},{"location":"etch-language/debug/#compiling","text":"Our compiler is very strict. It will complain about: Unknown and unsupported symbols, operators, and indexes. Lack of types for variables and parameters. Assigning null to primitive types. Incorrect, incompatible, and uninferrable types in statements and functions. Duplicate variables, parameters, and functions. Incomparable types in boolean tests. Unmatched and unexpected beginnings, middles, and endings in selections, iterations, statements, and blocks. Incorrectly formed statements. Incorrect amount, or lack of, operands in boolean tests. break and continue statements outside while or for loops. Non-functions, unmatched functions, and functions that do not return a value. Local function definitions. Returning null or no value from functions. Attempts to construct primitives and unmatched constructors. Mismatches between type and instance functions. Member access support issues with dot operator. while , for , if , var , return , break , continue , variables, and expressions declared at topmost scope.","title":"Compiling"},{"location":"etch-language/debug/#system-arguments","text":"System.Argc() and System.Argv() give access to compiler argument count and values. The following code prints the number of compiler arguments, then lists their values. function main () var message : String ; printLn ( \"System args: \" + toString ( System . Argc ())); // print the argument values for ( i in 0 : System . Argc ()) message = toString ( i ) + \" = \" + System . Argv ( i ); printLn ( message ); endfor endfunction Running the code from the command line with zero flags -- sends arguments to the etch executable. For example, run the code snippet above with zero flags -- and an example argument hello like this: ./etch sysargs-examples.etch -- hello You should see the following output: F E \u2571 etch v0 .1.0 - 30 - g557389e0 T C Copyright 2018 - 2019 ( c ) Fetch AI Ltd . H System args : 2 0 = . / etch 1 = hello etch features like this are useful for experimentation and debugging in a development environment. For example, the system arguments can load machine learning training data into a script. For smart contracts, there are flags, such as -data , which do specific things. We explain coding, compiling, contract flags, and all about etch smart contracts here .","title":"System arguments"},{"location":"etch-language/error-checking/","text":"The following functions help with diagnosing bugs and ensuring the correct state of variables and boolean tests. Panic Force runtime errors with panic() . Use panic for unrecoverable states. It terminates the program immediately and provides optional feedback. function main () var x = 1 ; var y = 2 ; var z = y + x ; printLn ( toString ( z )); z =- 2 ; if ( z != - 1 ) panic ( \"This is a terrible mistake!\" ); endif printLn ( toString ( z )); endfunction Assert Use assert to ensure state with optional feedback. function main () var x = 1 ; var y = 2 ; var z = y + x ; printLn ( toString ( z )); z =- 2 ; assert ( z == 1 ); assert ( z == 1 , \"Feedback here.\" ); printLn ( toString ( z )); endfunction","title":"Error checking"},{"location":"etch-language/error-checking/#panic","text":"Force runtime errors with panic() . Use panic for unrecoverable states. It terminates the program immediately and provides optional feedback. function main () var x = 1 ; var y = 2 ; var z = y + x ; printLn ( toString ( z )); z =- 2 ; if ( z != - 1 ) panic ( \"This is a terrible mistake!\" ); endif printLn ( toString ( z )); endfunction","title":"Panic"},{"location":"etch-language/error-checking/#assert","text":"Use assert to ensure state with optional feedback. function main () var x = 1 ; var y = 2 ; var z = y + x ; printLn ( toString ( z )); z =- 2 ; assert ( z == 1 ); assert ( z == 1 , \"Feedback here.\" ); printLn ( toString ( z )); endfunction","title":"Assert"},{"location":"etch-language/extending-etch/","text":"Extending etch Note Coming soon: details on extending etch in C++.","title":"Extending etch in C++"},{"location":"etch-language/functions/","text":"Functions Writing a function Coding a function in etch is straightforward. All etch programs run in the simulator are triggered by a main() function. This is for development purposes only. Smart contracts do not require a main() function. In the example below, a function myFunction() is called from main() . function main () myFunction (); endfunction // declare the function called from main() function myFunction () printLn ( \"hello\" ); endfunction Parameter and return types The iterative fibonacci function below takes a parameter n: Int32 which is a 32 bit integer type named n . The function returns an Int32 and declares this after the function name and parameter list as : Int32 . function fibonacci ( n : Int32 ) : Int32 var a = 0 ; var b = 1 ; var temp = 0 ; for ( i in 0 : n ) temp = a ; a = b ; b = temp + b ; printLn ( toString ( a )); endfor return a ; endfunction // call fibonacci from main() function main () fibonacci ( 10 ); endfunction Recursion Below is an example of the fibonacci function implemented with recursion. Warning Take care with recursion in smart contract code. function fibonacci ( n : Int32 ) : Int32 if ( n == 1 || n == 0 ) return 1 ; else return ( fibonacci ( n - 1 ) + fibonacci ( n - 2 )); endif endfunction function main () var nterms = 10 ; for ( i in 0 : nterms ) printLn ( toString ( fibonacci ( i ))); endfor endfunction Pass by reference All variables in etch are passed by reference. Attempting to reassign the value of a primitive variable passed to another function will cause a compilation error. function main () var original_value = 10 ; printLn ( original_value ); change_value ( original_value ); printLn ( original_value ); endfunction function change_value ( value : Int32 ) // value = 20 ; // error: assignment operand is not writeable. Failed to compile. endfunction The same is true of complex types. function main () var myArray = Array < Int32 > ( 5 ); change_value ( myArray ); endfunction function change_value ( value : Array < Int32 > ) // value = Array < Int32 > ( 3 ); // error: assignment operand is not writeable. Failed to compile. endfunction However, this is not the case with the internal state of object types such as Array . function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; printLn ( myArray ); change_value ( myArray ); printLn ( myArray ); endfunction function change_value ( myArray : Array < Int32 > ) myArray [ 2 ] = 100 ; endfunction Reassigning a primitive type to a new variable does not affect the original. function main () var x = 10 ; printLn ( x ); change_value ( x ); printLn ( x ); endfunction function change_value ( value : Int32 ) var y = 20 ; y = value ; printLn ( y ); y = 20 ; endfunction However, reassigning an object and changing any of its internal values does affect the original. function main () var myArray = Array < String > ( 2 ); myArray [ 0 ] = \"hello\" ; printLn ( myArray [ 0 ]); change_value ( myArray ); printLn ( myArray [ 0 ]); endfunction function change_value ( myArray : Array < String > ) myArray [ 0 ] = \"goodbye\" ; endfunction Utility functions Print printLn() is available for printing variables to the console with a line break. print() is available without a line break. Note etch strips out all printLn() statements in a release environment. This means that logs and other miscellaneous debug code never finds its way onto ledger shards. Sysargs The following System functions Argc() and Argv() return the number of arguments to etch and their value. These functions are only useful on the etch simulator outside of smart contract development. System.Argc() System.Argv() Type casting toInt8() toInt16() toInt64() toUInt8() toUInt16() toUInt32() toUInt64() toFloat32() toFloat64() toFixed32() toFixed64() toString() For example: function main () var x = 10 ; printLn ( x ); var y = toInt8 ( x ); printLn ( y ); var z = toInt16 ( x ); printLn ( z ); var a = toInt32 ( x ); printLn ( a ); var b = toInt64 ( x ); printLn ( b ); var c = toUInt8 ( x ); printLn ( c ); var d = toUInt16 ( x ); printLn ( d ); var e = toUInt32 ( x ); printLn ( e ); var f = toUInt64 ( x ); printLn ( f ); var g = toFloat32 ( x ); printLn ( g ); var h = toFloat64 ( x ); printLn ( h ); var i = toFixed32 ( x ); printLn ( i ); var j = toFixed64 ( x ); printLn ( j ); endfunction Annotations etch smart contract code includes annotated functions: @init is a constructor method that initialises the contract. @action is a function which defines transactions on the ledger that change state. @query is a function that allows you to query data residing on the ledger. There are more annotations for synergetic contracts. Getters and setters Getters and setters are available for State and ShardedState types. set() get()","title":"Functions"},{"location":"etch-language/functions/#writing-a-function","text":"Coding a function in etch is straightforward. All etch programs run in the simulator are triggered by a main() function. This is for development purposes only. Smart contracts do not require a main() function. In the example below, a function myFunction() is called from main() . function main () myFunction (); endfunction // declare the function called from main() function myFunction () printLn ( \"hello\" ); endfunction","title":"Writing a function"},{"location":"etch-language/functions/#parameter-and-return-types","text":"The iterative fibonacci function below takes a parameter n: Int32 which is a 32 bit integer type named n . The function returns an Int32 and declares this after the function name and parameter list as : Int32 . function fibonacci ( n : Int32 ) : Int32 var a = 0 ; var b = 1 ; var temp = 0 ; for ( i in 0 : n ) temp = a ; a = b ; b = temp + b ; printLn ( toString ( a )); endfor return a ; endfunction // call fibonacci from main() function main () fibonacci ( 10 ); endfunction","title":"Parameter and return types"},{"location":"etch-language/functions/#recursion","text":"Below is an example of the fibonacci function implemented with recursion. Warning Take care with recursion in smart contract code. function fibonacci ( n : Int32 ) : Int32 if ( n == 1 || n == 0 ) return 1 ; else return ( fibonacci ( n - 1 ) + fibonacci ( n - 2 )); endif endfunction function main () var nterms = 10 ; for ( i in 0 : nterms ) printLn ( toString ( fibonacci ( i ))); endfor endfunction","title":"Recursion"},{"location":"etch-language/functions/#pass-by-reference","text":"All variables in etch are passed by reference. Attempting to reassign the value of a primitive variable passed to another function will cause a compilation error. function main () var original_value = 10 ; printLn ( original_value ); change_value ( original_value ); printLn ( original_value ); endfunction function change_value ( value : Int32 ) // value = 20 ; // error: assignment operand is not writeable. Failed to compile. endfunction The same is true of complex types. function main () var myArray = Array < Int32 > ( 5 ); change_value ( myArray ); endfunction function change_value ( value : Array < Int32 > ) // value = Array < Int32 > ( 3 ); // error: assignment operand is not writeable. Failed to compile. endfunction However, this is not the case with the internal state of object types such as Array . function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; printLn ( myArray ); change_value ( myArray ); printLn ( myArray ); endfunction function change_value ( myArray : Array < Int32 > ) myArray [ 2 ] = 100 ; endfunction Reassigning a primitive type to a new variable does not affect the original. function main () var x = 10 ; printLn ( x ); change_value ( x ); printLn ( x ); endfunction function change_value ( value : Int32 ) var y = 20 ; y = value ; printLn ( y ); y = 20 ; endfunction However, reassigning an object and changing any of its internal values does affect the original. function main () var myArray = Array < String > ( 2 ); myArray [ 0 ] = \"hello\" ; printLn ( myArray [ 0 ]); change_value ( myArray ); printLn ( myArray [ 0 ]); endfunction function change_value ( myArray : Array < String > ) myArray [ 0 ] = \"goodbye\" ; endfunction","title":"Pass by reference"},{"location":"etch-language/functions/#utility-functions","text":"","title":"Utility functions"},{"location":"etch-language/functions/#print","text":"printLn() is available for printing variables to the console with a line break. print() is available without a line break. Note etch strips out all printLn() statements in a release environment. This means that logs and other miscellaneous debug code never finds its way onto ledger shards.","title":"Print"},{"location":"etch-language/functions/#sysargs","text":"The following System functions Argc() and Argv() return the number of arguments to etch and their value. These functions are only useful on the etch simulator outside of smart contract development. System.Argc() System.Argv()","title":"Sysargs"},{"location":"etch-language/functions/#type-casting","text":"toInt8() toInt16() toInt64() toUInt8() toUInt16() toUInt32() toUInt64() toFloat32() toFloat64() toFixed32() toFixed64() toString() For example: function main () var x = 10 ; printLn ( x ); var y = toInt8 ( x ); printLn ( y ); var z = toInt16 ( x ); printLn ( z ); var a = toInt32 ( x ); printLn ( a ); var b = toInt64 ( x ); printLn ( b ); var c = toUInt8 ( x ); printLn ( c ); var d = toUInt16 ( x ); printLn ( d ); var e = toUInt32 ( x ); printLn ( e ); var f = toUInt64 ( x ); printLn ( f ); var g = toFloat32 ( x ); printLn ( g ); var h = toFloat64 ( x ); printLn ( h ); var i = toFixed32 ( x ); printLn ( i ); var j = toFixed64 ( x ); printLn ( j ); endfunction","title":"Type casting"},{"location":"etch-language/functions/#annotations","text":"etch smart contract code includes annotated functions: @init is a constructor method that initialises the contract. @action is a function which defines transactions on the ledger that change state. @query is a function that allows you to query data residing on the ledger. There are more annotations for synergetic contracts.","title":"Annotations"},{"location":"etch-language/functions/#getters-and-setters","text":"Getters and setters are available for State and ShardedState types. set() get()","title":"Getters and setters"},{"location":"etch-language/getstarted/","text":"Getting started Prerequisites Get the Fetch.AI Ledger code from Git. Full initial installation and build instructions are here . Installation cd into build folder. Run make etch . Setup cd into apps/etch . Run ./etch with filename, flags, and arguments: ./etch [options] <filename> -- [script args] . For example: ./etch hello-world.etch -data test.json . This runs the hello-world.etch file and produces a json file containing info on the data required by the contract. Etch playground You can run all the examples in these docs in the etch playground here as well as on the command line. Hello world! Let\u2019s run our first etch program. Create a new file in the etch directory and save it as hello-world.etch . Add the following code: function main () printLn ( \"Hello world!\" ); endfunction Save the file. Run ./etch hello-world.etch . You should see the following output: $ . / etch hello - world . etch F E \u2571 etch v0 .1.0 - 23 - gd7622f98 T C Copyright 2018 - 2019 ( c ) Fetch AI Ltd . H Hello world !","title":"Getting started"},{"location":"etch-language/getstarted/#prerequisites","text":"Get the Fetch.AI Ledger code from Git. Full initial installation and build instructions are here .","title":"Prerequisites"},{"location":"etch-language/getstarted/#installation","text":"cd into build folder. Run make etch .","title":"Installation"},{"location":"etch-language/getstarted/#setup","text":"cd into apps/etch . Run ./etch with filename, flags, and arguments: ./etch [options] <filename> -- [script args] . For example: ./etch hello-world.etch -data test.json . This runs the hello-world.etch file and produces a json file containing info on the data required by the contract.","title":"Setup"},{"location":"etch-language/getstarted/#etch-playground","text":"You can run all the examples in these docs in the etch playground here as well as on the command line.","title":"Etch playground"},{"location":"etch-language/getstarted/#hello-world","text":"Let\u2019s run our first etch program. Create a new file in the etch directory and save it as hello-world.etch . Add the following code: function main () printLn ( \"Hello world!\" ); endfunction Save the file. Run ./etch hello-world.etch . You should see the following output: $ . / etch hello - world . etch F E \u2571 etch v0 .1.0 - 23 - gd7622f98 T C Copyright 2018 - 2019 ( c ) Fetch AI Ltd . H Hello world !","title":"Hello world!"},{"location":"etch-language/logic/","text":"Logical operators Equal to function main () var x = 12 ; var y = 12 ; if ( x == y ) printLn ( \"Equal.\" ); endif endfunction Not equal to function main () var x = 12 ; var y = 11 ; if ( x != y ) printLn ( \"Not equal.\" ); endif endfunction Less than function main () var x = 12 ; var y = 11 ; if ( y < x ) printLn ( \"Less than.\" ); endif if ( y <= x ) printLn ( \"Less than or equal to.\" ); endif endfunction More than function main () var x = 12 ; var y = 11 ; if ( x > y ) printLn ( \"More than.\" ); endif if ( x >= y ) printLn ( \"More than or equal to.\" ); endif endfunction And function main () var f : Bool = false ; var t : Bool = true ; if ( f && t ) printLn ( \"True.\" ); else printLn ( \"False.\" ); endif endfunction Or function main () var f : Bool = false ; var t : Bool = true ; if ( f || t ) printLn ( \"True.\" ); else printLn ( \"False.\" ); endif endfunction Xor Note Coming soon: support for xor .","title":"Logical operators"},{"location":"etch-language/logic/#equal-to","text":"function main () var x = 12 ; var y = 12 ; if ( x == y ) printLn ( \"Equal.\" ); endif endfunction","title":"Equal to"},{"location":"etch-language/logic/#not-equal-to","text":"function main () var x = 12 ; var y = 11 ; if ( x != y ) printLn ( \"Not equal.\" ); endif endfunction","title":"Not equal to"},{"location":"etch-language/logic/#less-than","text":"function main () var x = 12 ; var y = 11 ; if ( y < x ) printLn ( \"Less than.\" ); endif if ( y <= x ) printLn ( \"Less than or equal to.\" ); endif endfunction","title":"Less than"},{"location":"etch-language/logic/#more-than","text":"function main () var x = 12 ; var y = 11 ; if ( x > y ) printLn ( \"More than.\" ); endif if ( x >= y ) printLn ( \"More than or equal to.\" ); endif endfunction","title":"More than"},{"location":"etch-language/logic/#and","text":"function main () var f : Bool = false ; var t : Bool = true ; if ( f && t ) printLn ( \"True.\" ); else printLn ( \"False.\" ); endif endfunction","title":"And"},{"location":"etch-language/logic/#or","text":"function main () var f : Bool = false ; var t : Bool = true ; if ( f || t ) printLn ( \"True.\" ); else printLn ( \"False.\" ); endif endfunction","title":"Or"},{"location":"etch-language/logic/#xor","text":"Note Coming soon: support for xor .","title":"Xor"},{"location":"etch-language/maths-functions/","text":"In the current version, release/v0.6.x , the following maths functions are available: Absolute value abs() returns the absolute value of an Int32 or a Float64 . function main () // positive int 32 var x_int = 1 ; printLn ( toString ( abs ( x_int ))); // negative int 32 x_int = - 1 ; printLn ( toString ( abs ( x_int ))); // positive float 64 var x_float = 0.1123 ; printLn ( toString ( abs ( x_float ))); // negative float 64 x_float = - 7.151 ; printLn ( toString ( abs ( x_float ))); endfunction Exponent The exponential function returns the value of e to the number given, exp(x) = e x where e is Euler's base of natural logarithms. Currently, the exponent function is limited to fixed and floating point variables. function main () var a = 2.0f p32 ; var b = 3.0f p64 ; printLn ( toString ( exp ( a ))); printLn ( toString ( exp ( b ))); var c = 4.0f ; var d = 5.0 ; printLn ( toString ( exp ( c ))); printLn ( toString ( exp ( d ))); endfunction Logarithm Natural log values are currently available for UInt256 types only with the logValue() member function. function main () var uint256 = UInt256 ( 256u64 ); var logY = uint256 . logValue (); printLn ( logY ); endfunction In a future release, log values will be available for all types as well as in base 2 and 10. Power The power function returns the value of the first parameter raised to the second. Currently, the power function is limited to fixed and floating point variables. function main () var a = 2.0f p64 ; var b = 3.0f p64 ; printLn ( toString ( pow ( a , b ))); var c = 4.0f p32 ; var d = 5.0f p32 ; printLn ( toString ( pow ( c , d ))); var e = 2.0f ; var f = 3.0f ; printLn ( toString ( pow ( e , f ))); var g = 4.0 ; var h = 5.0 ; printLn ( toString ( pow ( g , h ))); endfunction Random (non deterministic) You can currently generate non-deterministic, random, signed and unsigned integers and floats. The beginning value of the range must be less than the end value. function main () // var randUInt8 = rand ( 0u8 , 1000u8 ); // error: unable to find matching function for 'Rand' //printLn(toString(randUInt8)); // unpermitted range // var rand_test = rand(100u16, 0u16); // runtime error: Invalid argument: rand(a, b) must satisfy a < b var randUInt16 = rand ( 0u16 , 1000u16 ); printLn ( toString ( randUInt16 )); var randUInt32 = rand ( 0u32 , 1000u32 ); printLn ( toString ( randUInt32 )); var randUInt64 = rand ( 0u64 , 1000u64 ); printLn ( toString ( randUInt64 )); // var randInt8 = rand(0u8, 1000u8); // printLn(toString(randInt8)); var randInt16 = rand ( 0 i16 , 1000 i16 ); printLn ( toString ( randInt16 )); var randInt32 = rand ( 0 i32 , 1000 i32 ); printLn ( toString ( randInt32 )); var randInt64 = rand ( 0 i64 , 1000 i64 ); printLn ( toString ( randInt64 )); var randFloat32 = rand ( 0.0f , 1000.0f ); printLn ( toString ( randFloat32 )); var randFloat64 = rand ( 0.0 , 1000.0 ); printLn ( toString ( randFloat64 )); endfunction Square root The square root of a number is found with the sqrt() function. Currently, the square root function is limited to fixed and floating point variables. function main () var a = 4.0f p32 ; var b = 49.0f p64 ; printLn ( toString ( sqrt ( a ))); printLn ( toString ( sqrt ( b ))); var c = 4.0f ; var d = 49.0 ; printLn ( toString ( sqrt ( c ))); printLn ( toString ( sqrt ( d ))); endfunction Trigonometry etch supports trigonometric functions Sin , Cos , and Tan . function main () var x = 1.0 ; printLn ( \"sin of 1\" ); printLn ( toString ( sin ( x ))); x = 0.5 ; printLn ( \"sin of 0.5\" ); printLn ( toString ( sin ( x ))); x = 0.0 ; printLn ( \"sin of 0\" ); printLn ( toString ( sin ( x ))); x = 1.0 ; printLn ( \"cos of 1\" ); printLn ( toString ( cos ( x ))); x = 0.5 ; printLn ( \"cos of 0.5\" ); printLn ( toString ( cos ( x ))); x = 0.0 ; printLn ( \"cos of 0\" ); printLn ( toString ( cos ( x ))); x = 1.0 ; printLn ( \"tan of 1\" ); printLn ( toString ( tan ( x ))); x = 0.5 ; printLn ( \"tan of 0.5\" ); printLn ( toString ( tan ( x ))); x = 0.0 ; printLn ( \"tan of 0\" ); printLn ( toString ( tan ( x ))); endfunction Also ArcSin , ArcCos , and ArcTan . function main () var x = 1.0 ; printLn ( \"asin of 1\" ); printLn ( toString ( asin ( x ))); x = 0.5 ; printLn ( \"asin of 0.5\" ); printLn ( toString ( asin ( x ))); x = 0.0 ; printLn ( \"asin of 0\" ); printLn ( toString ( asin ( x ))); x = 1.0 ; printLn ( \"acos of 1\" ); printLn ( toString ( acos ( x ))); x = 0.5 ; printLn ( \"acos of 0.5\" ); printLn ( toString ( acos ( x ))); x = 0.0 ; printLn ( \"acos of 0\" ); printLn ( toString ( acos ( x ))); x = 1.0 ; printLn ( \"atan of 1\" ); printLn ( toString ( atan ( x ))); x = 0.5 ; printLn ( \"atan of 0.5\" ); printLn ( toString ( atan ( x ))); x = 0.0 ; printLn ( \"atan of 0\" ); printLn ( toString ( atan ( x ))); endfunction And hyperbolic functions of Sin , Cos , and Tan . function main () var x = 1.0 ; printLn ( \"sinh of 1\" ); printLn ( toString ( sinh ( x ))); x = 0.5 ; printLn ( \"sinh of 0.5\" ); printLn ( toString ( sinh ( x ))); x = 0.0 ; printLn ( \"sinh of 0\" ); printLn ( toString ( sinh ( x ))); x = 1.0 ; printLn ( \"cosh of 1\" ); printLn ( toString ( cosh ( x ))); x = 0.5 ; printLn ( \"cosh of 0.5\" ); printLn ( toString ( cosh ( x ))); x = 0.0 ; printLn ( \"cosh of 0\" ); printLn ( toString ( cosh ( x ))); x = 1.0 ; printLn ( \"tanh of 1\" ); printLn ( toString ( tanh ( x ))); x = 0.5 ; printLn ( \"tanh of 0.5\" ); printLn ( toString ( tanh ( x ))); x = 0.0 ; printLn ( \"tanh of 0\" ); printLn ( toString ( tanh ( x ))); endfunction And hyperbolic ArcSin , ArcCos , and ArcTan . function main () var x = 1.0 ; printLn ( \"asinh of 1\" ); printLn ( toString ( asinh ( x ))); x = 0.5 ; printLn ( \"asinh of 0.5\" ); printLn ( toString ( asinh ( x ))); x = 0.0 ; printLn ( \"asinh of 0\" ); printLn ( toString ( asinh ( x ))); x = 1.0 ; printLn ( \"acosh of 1\" ); printLn ( toString ( acosh ( x ))); x = 0.5 ; printLn ( \"acosh of 0.5\" ); printLn ( toString ( acosh ( x ))); x = 0.0 ; printLn ( \"acosh of 0\" ); printLn ( toString ( acosh ( x ))); x = 1.0 ; printLn ( \"atanh of 1\" ); printLn ( toString ( atanh ( x ))); x = 0.5 ; printLn ( \"atanh of 0.5\" ); printLn ( toString ( atanh ( x ))); x = 0.0 ; printLn ( \"atanh of 0\" ); printLn ( toString ( atanh ( x ))); endfunction","title":"Maths functions"},{"location":"etch-language/maths-functions/#absolute-value","text":"abs() returns the absolute value of an Int32 or a Float64 . function main () // positive int 32 var x_int = 1 ; printLn ( toString ( abs ( x_int ))); // negative int 32 x_int = - 1 ; printLn ( toString ( abs ( x_int ))); // positive float 64 var x_float = 0.1123 ; printLn ( toString ( abs ( x_float ))); // negative float 64 x_float = - 7.151 ; printLn ( toString ( abs ( x_float ))); endfunction","title":"Absolute value"},{"location":"etch-language/maths-functions/#exponent","text":"The exponential function returns the value of e to the number given, exp(x) = e x where e is Euler's base of natural logarithms. Currently, the exponent function is limited to fixed and floating point variables. function main () var a = 2.0f p32 ; var b = 3.0f p64 ; printLn ( toString ( exp ( a ))); printLn ( toString ( exp ( b ))); var c = 4.0f ; var d = 5.0 ; printLn ( toString ( exp ( c ))); printLn ( toString ( exp ( d ))); endfunction","title":"Exponent"},{"location":"etch-language/maths-functions/#logarithm","text":"Natural log values are currently available for UInt256 types only with the logValue() member function. function main () var uint256 = UInt256 ( 256u64 ); var logY = uint256 . logValue (); printLn ( logY ); endfunction In a future release, log values will be available for all types as well as in base 2 and 10.","title":"Logarithm"},{"location":"etch-language/maths-functions/#power","text":"The power function returns the value of the first parameter raised to the second. Currently, the power function is limited to fixed and floating point variables. function main () var a = 2.0f p64 ; var b = 3.0f p64 ; printLn ( toString ( pow ( a , b ))); var c = 4.0f p32 ; var d = 5.0f p32 ; printLn ( toString ( pow ( c , d ))); var e = 2.0f ; var f = 3.0f ; printLn ( toString ( pow ( e , f ))); var g = 4.0 ; var h = 5.0 ; printLn ( toString ( pow ( g , h ))); endfunction","title":"Power"},{"location":"etch-language/maths-functions/#random-non-deterministic","text":"You can currently generate non-deterministic, random, signed and unsigned integers and floats. The beginning value of the range must be less than the end value. function main () // var randUInt8 = rand ( 0u8 , 1000u8 ); // error: unable to find matching function for 'Rand' //printLn(toString(randUInt8)); // unpermitted range // var rand_test = rand(100u16, 0u16); // runtime error: Invalid argument: rand(a, b) must satisfy a < b var randUInt16 = rand ( 0u16 , 1000u16 ); printLn ( toString ( randUInt16 )); var randUInt32 = rand ( 0u32 , 1000u32 ); printLn ( toString ( randUInt32 )); var randUInt64 = rand ( 0u64 , 1000u64 ); printLn ( toString ( randUInt64 )); // var randInt8 = rand(0u8, 1000u8); // printLn(toString(randInt8)); var randInt16 = rand ( 0 i16 , 1000 i16 ); printLn ( toString ( randInt16 )); var randInt32 = rand ( 0 i32 , 1000 i32 ); printLn ( toString ( randInt32 )); var randInt64 = rand ( 0 i64 , 1000 i64 ); printLn ( toString ( randInt64 )); var randFloat32 = rand ( 0.0f , 1000.0f ); printLn ( toString ( randFloat32 )); var randFloat64 = rand ( 0.0 , 1000.0 ); printLn ( toString ( randFloat64 )); endfunction","title":"Random (non deterministic)"},{"location":"etch-language/maths-functions/#square-root","text":"The square root of a number is found with the sqrt() function. Currently, the square root function is limited to fixed and floating point variables. function main () var a = 4.0f p32 ; var b = 49.0f p64 ; printLn ( toString ( sqrt ( a ))); printLn ( toString ( sqrt ( b ))); var c = 4.0f ; var d = 49.0 ; printLn ( toString ( sqrt ( c ))); printLn ( toString ( sqrt ( d ))); endfunction","title":"Square root"},{"location":"etch-language/maths-functions/#trigonometry","text":"etch supports trigonometric functions Sin , Cos , and Tan . function main () var x = 1.0 ; printLn ( \"sin of 1\" ); printLn ( toString ( sin ( x ))); x = 0.5 ; printLn ( \"sin of 0.5\" ); printLn ( toString ( sin ( x ))); x = 0.0 ; printLn ( \"sin of 0\" ); printLn ( toString ( sin ( x ))); x = 1.0 ; printLn ( \"cos of 1\" ); printLn ( toString ( cos ( x ))); x = 0.5 ; printLn ( \"cos of 0.5\" ); printLn ( toString ( cos ( x ))); x = 0.0 ; printLn ( \"cos of 0\" ); printLn ( toString ( cos ( x ))); x = 1.0 ; printLn ( \"tan of 1\" ); printLn ( toString ( tan ( x ))); x = 0.5 ; printLn ( \"tan of 0.5\" ); printLn ( toString ( tan ( x ))); x = 0.0 ; printLn ( \"tan of 0\" ); printLn ( toString ( tan ( x ))); endfunction Also ArcSin , ArcCos , and ArcTan . function main () var x = 1.0 ; printLn ( \"asin of 1\" ); printLn ( toString ( asin ( x ))); x = 0.5 ; printLn ( \"asin of 0.5\" ); printLn ( toString ( asin ( x ))); x = 0.0 ; printLn ( \"asin of 0\" ); printLn ( toString ( asin ( x ))); x = 1.0 ; printLn ( \"acos of 1\" ); printLn ( toString ( acos ( x ))); x = 0.5 ; printLn ( \"acos of 0.5\" ); printLn ( toString ( acos ( x ))); x = 0.0 ; printLn ( \"acos of 0\" ); printLn ( toString ( acos ( x ))); x = 1.0 ; printLn ( \"atan of 1\" ); printLn ( toString ( atan ( x ))); x = 0.5 ; printLn ( \"atan of 0.5\" ); printLn ( toString ( atan ( x ))); x = 0.0 ; printLn ( \"atan of 0\" ); printLn ( toString ( atan ( x ))); endfunction And hyperbolic functions of Sin , Cos , and Tan . function main () var x = 1.0 ; printLn ( \"sinh of 1\" ); printLn ( toString ( sinh ( x ))); x = 0.5 ; printLn ( \"sinh of 0.5\" ); printLn ( toString ( sinh ( x ))); x = 0.0 ; printLn ( \"sinh of 0\" ); printLn ( toString ( sinh ( x ))); x = 1.0 ; printLn ( \"cosh of 1\" ); printLn ( toString ( cosh ( x ))); x = 0.5 ; printLn ( \"cosh of 0.5\" ); printLn ( toString ( cosh ( x ))); x = 0.0 ; printLn ( \"cosh of 0\" ); printLn ( toString ( cosh ( x ))); x = 1.0 ; printLn ( \"tanh of 1\" ); printLn ( toString ( tanh ( x ))); x = 0.5 ; printLn ( \"tanh of 0.5\" ); printLn ( toString ( tanh ( x ))); x = 0.0 ; printLn ( \"tanh of 0\" ); printLn ( toString ( tanh ( x ))); endfunction And hyperbolic ArcSin , ArcCos , and ArcTan . function main () var x = 1.0 ; printLn ( \"asinh of 1\" ); printLn ( toString ( asinh ( x ))); x = 0.5 ; printLn ( \"asinh of 0.5\" ); printLn ( toString ( asinh ( x ))); x = 0.0 ; printLn ( \"asinh of 0\" ); printLn ( toString ( asinh ( x ))); x = 1.0 ; printLn ( \"acosh of 1\" ); printLn ( toString ( acosh ( x ))); x = 0.5 ; printLn ( \"acosh of 0.5\" ); printLn ( toString ( acosh ( x ))); x = 0.0 ; printLn ( \"acosh of 0\" ); printLn ( toString ( acosh ( x ))); x = 1.0 ; printLn ( \"atanh of 1\" ); printLn ( toString ( atanh ( x ))); x = 0.5 ; printLn ( \"atanh of 0.5\" ); printLn ( toString ( atanh ( x ))); x = 0.0 ; printLn ( \"atanh of 0\" ); printLn ( toString ( atanh ( x ))); endfunction","title":"Trigonometry"},{"location":"etch-language/ml-functions/","text":"Note Coming soon: Tensors. Graphs. Graph operations (MatMul, convolution, etc.). Activations (relu, sigmoid, softmax, etc.). Loss Functions (MeanSquareError, CrossEntropy, KLDivergence, etc.). DataLoaders.","title":"Machine learning functions"},{"location":"etch-language/operators/","text":"Operators + += == != ( ) && - -= || < < = [ ] * *= > >= / /= ++ = : , % %= -- ! . Minus function main () var plus = 42 ; var minus = - 42 ; printLn ( toString ( plus )); printLn ( toString ( minus )); var plusminused = - plus ; printLn ( toString ( plusminused )); endfunction Increment function main () var int32bit : Int32 = 42 ; int32bit ++ ; printLn ( toString ( int32bit )); ++ int32bit ; printLn ( toString ( int32bit )); endfunction Decrement function main () var int32bit : Int32 = 42 ; int32bit -- ; printLn ( toString ( int32bit )); -- int32bit ; printLn ( toString ( int32bit )); endfunction Addition function main () var x = 42 ; var y = 66 ; var z = x + y ; printLn ( toString ( z )); z += 2 ; printLn ( toString ( z )); endfunction Subtraction function main () var x = 42 ; var y = 66 ; var z = y - x ; printLn ( toString ( z )); z -= 2 ; printLn ( toString ( z )); endfunction Multiplication function main () var x = 42 ; var y = 2 ; var z = y * x ; printLn ( toString ( z )); z *= 2 ; printLn ( toString ( z )); endfunction Division Integer division returns a rounded down integer value. function main () var x = 41 ; var y = 7 ; var z = x / y ; printLn ( toString ( z )); z /= 2 ; printLn ( toString ( z )); var a = 32.3f ; var b = 31.2f ; var c = a / b ; printLn ( toString ( c )); endfunction Modulus function main () var x = 7 ; var y = 6 ; var z = x % y ; printLn ( toString ( z )); z %= 2 ; printLn ( toString ( z )); endfunction Ternary Not currently supported. Precedence 1. x ++ x -- subscript [] . 2. ++ x -- x ( + x ) - x ! toType 3. * / % 4. + - 5. < <= > >= 6. == != 7. && 8. || 9. = += -= *= /= 10. ,","title":"Operators"},{"location":"etch-language/operators/#minus","text":"function main () var plus = 42 ; var minus = - 42 ; printLn ( toString ( plus )); printLn ( toString ( minus )); var plusminused = - plus ; printLn ( toString ( plusminused )); endfunction","title":"Minus"},{"location":"etch-language/operators/#increment","text":"function main () var int32bit : Int32 = 42 ; int32bit ++ ; printLn ( toString ( int32bit )); ++ int32bit ; printLn ( toString ( int32bit )); endfunction","title":"Increment"},{"location":"etch-language/operators/#decrement","text":"function main () var int32bit : Int32 = 42 ; int32bit -- ; printLn ( toString ( int32bit )); -- int32bit ; printLn ( toString ( int32bit )); endfunction","title":"Decrement"},{"location":"etch-language/operators/#addition","text":"function main () var x = 42 ; var y = 66 ; var z = x + y ; printLn ( toString ( z )); z += 2 ; printLn ( toString ( z )); endfunction","title":"Addition"},{"location":"etch-language/operators/#subtraction","text":"function main () var x = 42 ; var y = 66 ; var z = y - x ; printLn ( toString ( z )); z -= 2 ; printLn ( toString ( z )); endfunction","title":"Subtraction"},{"location":"etch-language/operators/#multiplication","text":"function main () var x = 42 ; var y = 2 ; var z = y * x ; printLn ( toString ( z )); z *= 2 ; printLn ( toString ( z )); endfunction","title":"Multiplication"},{"location":"etch-language/operators/#division","text":"Integer division returns a rounded down integer value. function main () var x = 41 ; var y = 7 ; var z = x / y ; printLn ( toString ( z )); z /= 2 ; printLn ( toString ( z )); var a = 32.3f ; var b = 31.2f ; var c = a / b ; printLn ( toString ( c )); endfunction","title":"Division"},{"location":"etch-language/operators/#modulus","text":"function main () var x = 7 ; var y = 6 ; var z = x % y ; printLn ( toString ( z )); z %= 2 ; printLn ( toString ( z )); endfunction","title":"Modulus"},{"location":"etch-language/operators/#ternary","text":"Not currently supported.","title":"Ternary"},{"location":"etch-language/operators/#precedence","text":"1. x ++ x -- subscript [] . 2. ++ x -- x ( + x ) - x ! toType 3. * / % 4. + - 5. < <= > >= 6. == != 7. && 8. || 9. = += -= *= /= 10. ,","title":"Precedence"},{"location":"etch-language/regex/","text":"Regular expressions Note Coming soon: support for regular expressions.","title":"Regex"},{"location":"etch-language/release-notes/","text":"Version 0.6.x Significant changes in this version of the etch virtual machine include the following: vm-lang is now called etch . For loops are non-inclusive. Array ranges are non-inclusive. Short circuiting implemented for && and || expressions. StructuredData type can be used as a serialised object.","title":"Release notes"},{"location":"etch-language/release-notes/#version-06x","text":"Significant changes in this version of the etch virtual machine include the following: vm-lang is now called etch . For loops are non-inclusive. Array ranges are non-inclusive. Short circuiting implemented for && and || expressions. StructuredData type can be used as a serialised object.","title":"Version 0.6.x"},{"location":"etch-language/sharded-state/","text":"Sharded States A ShardedState is like a State type in that data contained within a ShardedState will be etched upon the ledger. The key difference is that a ShardedState is a map, containing key/value pairs. A key must be a String or Address type. Behind the scenes, ShardedState creates anonymous State types for key/value pairs that etch onto the ledger. Declaration Declare a ShardedState in the same way you declare a State : function main () var state = ShardedState < Int32 > ( \"account1\" ); endfunction The account1 identifier is the pointer to the place in memory that holds the data. Add key/value pairs Add key/value pairs to the ShardedState like this: function main () var myShardedState = ShardedState < Int32 > ( \"account1\" ); myShardedState . set ( \"sales\" , 0 i32 ); myShardedState . set ( \"gross_profit\" , 0 i32 ); myShardedState . set ( \"net_profit\" , 0 i32 ); set_values_on_state (); endfunction function set_values_on_state () var state = ShardedState < Int32 > ( \"account1\" ); state . set ( \"sales\" , 2000000 ); state . set ( \"gross_profit\" , 1800000 ); state . set ( \"net_profit\" , 1300000 ); endfunction Querying with default values Let's add some query functions to get the ShardedState values. Notice that when you query the data, you provide default values and receive the actual value. Note The annotation @query is used in smart contract code and unnecessary for testing with the etch VM. function main () var myShardedState = ShardedState < Int32 > ( \"account1\" ); myShardedState . set ( \"sales\" , 0 i32 ); myShardedState . set ( \"gross_profit\" , 0 i32 ); myShardedState . set ( \"net_profit\" , 0 i32 ); set_values_on_state (); printLn ( query_sales ()); printLn ( query_gross_profit ()); printLn ( query_net_profit ()); endfunction function set_values_on_state () var state = ShardedState < Int32 > ( \"account1\" ); state . set ( \"sales\" , 2000000 ); state . set ( \"gross_profit\" , 1800000 ); state . set ( \"net_profit\" , 1300000 ); endfunction @ query function query_sales () : Int32 var state = ShardedState < Int32 > ( \"account1\" ); return state . get ( \"sales\" , 0 i32 ); endfunction @ query function query_gross_profit () : Int32 var state = ShardedState < Int32 > ( \"account1\" ); return state . get ( \"gross_profit\" , 0 i32 ); endfunction @ query function query_net_profit () : Int32 var state = ShardedState < Int32 > ( \"account1\" ); return state . get ( \"net_profit\" , 0 i32 ); endfunction ShardedState types with Address references You can create ShardedState types using Address types as the reference. function main () var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var myState = ShardedState < Int32 > ( account ); myState . set ( \"balance\" , 100 ); myState . set ( \"transx1\" , - 10 ); myState . set ( \"transx2\" , 30 ); printLn ( \"My account balance = \" + toString ( myState . get ( \"balance\" ))); endfunction Writing ShardedState data to the ledger Any number of var identifiers can point to the same ShardedState object. function main () var x = ShardedState < Int32 > ( \"account1\" ); var y = ShardedState < Int32 > ( \"account1\" ); x . set ( \"balance\" , 100 ); y . set ( \"balance\" , - 10 ); printLn ( \"My state value = \" + toString ( x . get ( \"balance\" ))); endfunction","title":"ShardedState"},{"location":"etch-language/sharded-state/#declaration","text":"Declare a ShardedState in the same way you declare a State : function main () var state = ShardedState < Int32 > ( \"account1\" ); endfunction The account1 identifier is the pointer to the place in memory that holds the data.","title":"Declaration"},{"location":"etch-language/sharded-state/#add-keyvalue-pairs","text":"Add key/value pairs to the ShardedState like this: function main () var myShardedState = ShardedState < Int32 > ( \"account1\" ); myShardedState . set ( \"sales\" , 0 i32 ); myShardedState . set ( \"gross_profit\" , 0 i32 ); myShardedState . set ( \"net_profit\" , 0 i32 ); set_values_on_state (); endfunction function set_values_on_state () var state = ShardedState < Int32 > ( \"account1\" ); state . set ( \"sales\" , 2000000 ); state . set ( \"gross_profit\" , 1800000 ); state . set ( \"net_profit\" , 1300000 ); endfunction","title":"Add key/value pairs"},{"location":"etch-language/sharded-state/#querying-with-default-values","text":"Let's add some query functions to get the ShardedState values. Notice that when you query the data, you provide default values and receive the actual value. Note The annotation @query is used in smart contract code and unnecessary for testing with the etch VM. function main () var myShardedState = ShardedState < Int32 > ( \"account1\" ); myShardedState . set ( \"sales\" , 0 i32 ); myShardedState . set ( \"gross_profit\" , 0 i32 ); myShardedState . set ( \"net_profit\" , 0 i32 ); set_values_on_state (); printLn ( query_sales ()); printLn ( query_gross_profit ()); printLn ( query_net_profit ()); endfunction function set_values_on_state () var state = ShardedState < Int32 > ( \"account1\" ); state . set ( \"sales\" , 2000000 ); state . set ( \"gross_profit\" , 1800000 ); state . set ( \"net_profit\" , 1300000 ); endfunction @ query function query_sales () : Int32 var state = ShardedState < Int32 > ( \"account1\" ); return state . get ( \"sales\" , 0 i32 ); endfunction @ query function query_gross_profit () : Int32 var state = ShardedState < Int32 > ( \"account1\" ); return state . get ( \"gross_profit\" , 0 i32 ); endfunction @ query function query_net_profit () : Int32 var state = ShardedState < Int32 > ( \"account1\" ); return state . get ( \"net_profit\" , 0 i32 ); endfunction","title":"Querying with default values"},{"location":"etch-language/sharded-state/#shardedstate-types-with-address-references","text":"You can create ShardedState types using Address types as the reference. function main () var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var myState = ShardedState < Int32 > ( account ); myState . set ( \"balance\" , 100 ); myState . set ( \"transx1\" , - 10 ); myState . set ( \"transx2\" , 30 ); printLn ( \"My account balance = \" + toString ( myState . get ( \"balance\" ))); endfunction","title":"ShardedState types with Address references"},{"location":"etch-language/sharded-state/#writing-shardedstate-data-to-the-ledger","text":"Any number of var identifiers can point to the same ShardedState object. function main () var x = ShardedState < Int32 > ( \"account1\" ); var y = ShardedState < Int32 > ( \"account1\" ); x . set ( \"balance\" , 100 ); y . set ( \"balance\" , - 10 ); printLn ( \"My state value = \" + toString ( x . get ( \"balance\" ))); endfunction","title":"Writing ShardedState data to the ledger"},{"location":"etch-language/states/","text":"States Introduction to State variables A State provides persistent storage for smart contracts. It\u2019s like a global variable that is always there when any function of your contract runs. A smart contract might use a State to store the total supply or use multiple State variables to keep a track of who has what, for example. It can also let a contract track whether some events have occurred before it releases tokens. Declare a State like this: var myState1 = State < Int32 > ( \"simple_state_declaration\" ); Or even this: var myState2 = State < Array < Array < Array < String >>>> ( \"nested_array_state_declaration\" ); A State is not like a normal variable, you have to create a reference to it. For example: function main () var supply = UInt256 ( 1000u64 ); var contract_amount_state = State < UInt256 > ( \"contract_amount\" ); contract_amount_state . set ( supply ); endfunction The above code creates a variable name contract_amount_state and assigns it to a State<Int32> with a reference contract_amount . It then sets a value on the State . State references can be Address types. function main () var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var supply = UInt256 ( 1000u64 ); var myState = State < UInt256 > ( account ); myState . set ( supply ); endfunction State references can also be strings and you can get and set values on a State object. function main () var contract_amount_state = State < UInt256 > ( \"contract_amount\" ); var supply = UInt256 ( 1000u64 ); contract_amount_state . set ( supply ); var contract_amount = contract_amount_state . get (); printLn ( \"My state value = \" + toString ( contract_amount_state . get ())); endfunction Default values If a value has not yet been set on the State object and the State does not already exist on the ledger, a run-time error is thrown on calling get() . To avoid this, use with care get(<default value>) with a default value. For example, the following code prints zero if the state doesn't exist and the value that was originally set on it if it does exist. function main () var contract_amount_state = State < Int32 > ( \"contract_amount\" ); var contract_amount = contract_amount_state . get ( 0 ); printLn ( toString ( contract_amount )); endfunction Test a State exists You can test if a state already exists with existed() . function main () var contract_amount_state = State < Int32 > ( \"contract_amount\" ); if ( contract_amount_state . existed ()) printLn ( \"Yes, it exists.\" ); else printLn ( \"This state does not exist.\" ); endif endfunction This test is useful for scenarios in which you use states to see who has what, as you might do in a token contract where you need to keep track of who has the tokens. State references and scope In the example below, ownerState and contractState point to the same State object on the ledger. function main () var owner = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var ownerState = State < Int32 > ( owner ); ownerState . set ( 333 ); printLn ( \"My state value = \" + toString ( ownerState . get ())); var contractState = State < Int32 > ( owner ); // printLn(\"My state value = \" + toString(contractState.get())); // runtime error: line 7: The state does not represent any value. // The value has not been assigned and/or it does not exist in data storage. endfunction Assuming the referenced State object does not exist on the ledger, attempting to print the value of the second declaration of State generates an error - even though a value was set on it previously. This is because the data set in ownerState has not yet been written to the intermediate cache or ledger storage, so when contractState tries to access it, it finds no value and the etch VM generates a runtime error. Writing State data to the ledger The following is true for State variables declared with a var identifier. Currently, State data is written to smart contract intermediate cache only after control has passed out of function scope. While identifiable State variables remain inside function scope, data is written to an intermediate object cache mechanism at construction time. Within the same scope, such data is inaccessible to new State identifiers (which have not explicitly called set() on the State ). You cannot access a value set on a State if the function scope in which it was created is still open. function main () var state = State < Int32 > ( \"value\" ); state . set ( 11 ); printLn ( state . get ()); var value1 = value (); printLn ( toString ( value1 )); // scope not yet closed therefore runtime error: // The state does not represent any value. // The value has not been assigned and/or it does not exist in data storage. endfunction function value () : Int32 var state = State < Int32 > ( \"value\" ); return state . get (); endfunction Once control reaches the end of the function, the data is written to an intermediate ledger cache mechanism and is available throughout the contract. Once control has reached the end of the contract, and no errors have arisen, the data is etched upon the ledger. Anonymous State types Declaring an anonymous State type without a var name performs an immediate data write. function main () State < String > ( \"account1\" ). set ( \"owner1_name\" ); var account1 = State < String > ( \"account1\" ); printLn ( account1 . get ()); endfunction This is useful for ShardedState types which build up with immediate write anonymous State types behind the scenes. Passing States around The following code shows the behaviour of State types as they are passed around functions. State values are available to get() if the function scope they were created in originally has closed. function main () var myState = State < Int32 > ( \"contract_owner_balance\" ); myState . set ( 33 ); printLn ( toString ( myState . get ())); // PRINTS 33 change_state ( myState ); printLn ( toString ( myState . get ())); // PRINTS 44 var result = query (); printLn ( toString ( result )); // PRINTS 55 endfunction function change_state ( state : State < Int32 > ) // you can pass around a State parameter and get access to the original state var newState = state ; newState . set ( 44 ); // a new state with pointer = \"balance\" var anotherState = State < Int32 > ( \"balance\" ); anotherState . set ( 55 ); // all states from this function are written now endfunction function query () : Int32 // accessing the State at pointer = \"balance\", a value out of scope var myState = State < Int32 > ( \"balance\" ); // returns the 55 set in change_state() return myState . get (); endfunction Verify an Address Often, a contract needs to confirm whether an @action or @query comes from a specific address. This can be done with the signedTx() function of the Address type. In the example below, an @action establishes if the the signer of the calling transaction is a specific authorised address. function main () var owner = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var authorised = State < Address > ( \"owner\" ); authorised . set ( owner ); doSomething ( owner ); endfunction @ action function doSomething ( signer : Address ) if ( ! signer . signedTx ()) panic ( \"This address doesn't verify, stopping here.\" ); endif // Get the authorised address from the ledger var authorised_state = State < Address > ( \"owner\" ); var authorised_address = authorised_state . get (); if ( authorised_address != signer ) panic ( \"Incorrect address used to trigger\" ); endif // ... we're good to go, the signer of the TX is the stored authorised address... endfunction","title":"State"},{"location":"etch-language/states/#introduction-to-state-variables","text":"A State provides persistent storage for smart contracts. It\u2019s like a global variable that is always there when any function of your contract runs. A smart contract might use a State to store the total supply or use multiple State variables to keep a track of who has what, for example. It can also let a contract track whether some events have occurred before it releases tokens. Declare a State like this: var myState1 = State < Int32 > ( \"simple_state_declaration\" ); Or even this: var myState2 = State < Array < Array < Array < String >>>> ( \"nested_array_state_declaration\" ); A State is not like a normal variable, you have to create a reference to it. For example: function main () var supply = UInt256 ( 1000u64 ); var contract_amount_state = State < UInt256 > ( \"contract_amount\" ); contract_amount_state . set ( supply ); endfunction The above code creates a variable name contract_amount_state and assigns it to a State<Int32> with a reference contract_amount . It then sets a value on the State . State references can be Address types. function main () var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var supply = UInt256 ( 1000u64 ); var myState = State < UInt256 > ( account ); myState . set ( supply ); endfunction State references can also be strings and you can get and set values on a State object. function main () var contract_amount_state = State < UInt256 > ( \"contract_amount\" ); var supply = UInt256 ( 1000u64 ); contract_amount_state . set ( supply ); var contract_amount = contract_amount_state . get (); printLn ( \"My state value = \" + toString ( contract_amount_state . get ())); endfunction","title":"Introduction to State variables"},{"location":"etch-language/states/#default-values","text":"If a value has not yet been set on the State object and the State does not already exist on the ledger, a run-time error is thrown on calling get() . To avoid this, use with care get(<default value>) with a default value. For example, the following code prints zero if the state doesn't exist and the value that was originally set on it if it does exist. function main () var contract_amount_state = State < Int32 > ( \"contract_amount\" ); var contract_amount = contract_amount_state . get ( 0 ); printLn ( toString ( contract_amount )); endfunction","title":"Default values"},{"location":"etch-language/states/#test-a-state-exists","text":"You can test if a state already exists with existed() . function main () var contract_amount_state = State < Int32 > ( \"contract_amount\" ); if ( contract_amount_state . existed ()) printLn ( \"Yes, it exists.\" ); else printLn ( \"This state does not exist.\" ); endif endfunction This test is useful for scenarios in which you use states to see who has what, as you might do in a token contract where you need to keep track of who has the tokens.","title":"Test a State exists"},{"location":"etch-language/states/#state-references-and-scope","text":"In the example below, ownerState and contractState point to the same State object on the ledger. function main () var owner = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var ownerState = State < Int32 > ( owner ); ownerState . set ( 333 ); printLn ( \"My state value = \" + toString ( ownerState . get ())); var contractState = State < Int32 > ( owner ); // printLn(\"My state value = \" + toString(contractState.get())); // runtime error: line 7: The state does not represent any value. // The value has not been assigned and/or it does not exist in data storage. endfunction Assuming the referenced State object does not exist on the ledger, attempting to print the value of the second declaration of State generates an error - even though a value was set on it previously. This is because the data set in ownerState has not yet been written to the intermediate cache or ledger storage, so when contractState tries to access it, it finds no value and the etch VM generates a runtime error.","title":"State references and scope"},{"location":"etch-language/states/#writing-state-data-to-the-ledger","text":"The following is true for State variables declared with a var identifier. Currently, State data is written to smart contract intermediate cache only after control has passed out of function scope. While identifiable State variables remain inside function scope, data is written to an intermediate object cache mechanism at construction time. Within the same scope, such data is inaccessible to new State identifiers (which have not explicitly called set() on the State ). You cannot access a value set on a State if the function scope in which it was created is still open. function main () var state = State < Int32 > ( \"value\" ); state . set ( 11 ); printLn ( state . get ()); var value1 = value (); printLn ( toString ( value1 )); // scope not yet closed therefore runtime error: // The state does not represent any value. // The value has not been assigned and/or it does not exist in data storage. endfunction function value () : Int32 var state = State < Int32 > ( \"value\" ); return state . get (); endfunction Once control reaches the end of the function, the data is written to an intermediate ledger cache mechanism and is available throughout the contract. Once control has reached the end of the contract, and no errors have arisen, the data is etched upon the ledger.","title":"Writing State data to the ledger"},{"location":"etch-language/states/#anonymous-state-types","text":"Declaring an anonymous State type without a var name performs an immediate data write. function main () State < String > ( \"account1\" ). set ( \"owner1_name\" ); var account1 = State < String > ( \"account1\" ); printLn ( account1 . get ()); endfunction This is useful for ShardedState types which build up with immediate write anonymous State types behind the scenes.","title":"Anonymous State types"},{"location":"etch-language/states/#passing-states-around","text":"The following code shows the behaviour of State types as they are passed around functions. State values are available to get() if the function scope they were created in originally has closed. function main () var myState = State < Int32 > ( \"contract_owner_balance\" ); myState . set ( 33 ); printLn ( toString ( myState . get ())); // PRINTS 33 change_state ( myState ); printLn ( toString ( myState . get ())); // PRINTS 44 var result = query (); printLn ( toString ( result )); // PRINTS 55 endfunction function change_state ( state : State < Int32 > ) // you can pass around a State parameter and get access to the original state var newState = state ; newState . set ( 44 ); // a new state with pointer = \"balance\" var anotherState = State < Int32 > ( \"balance\" ); anotherState . set ( 55 ); // all states from this function are written now endfunction function query () : Int32 // accessing the State at pointer = \"balance\", a value out of scope var myState = State < Int32 > ( \"balance\" ); // returns the 55 set in change_state() return myState . get (); endfunction","title":"Passing States around"},{"location":"etch-language/states/#verify-an-address","text":"Often, a contract needs to confirm whether an @action or @query comes from a specific address. This can be done with the signedTx() function of the Address type. In the example below, an @action establishes if the the signer of the calling transaction is a specific authorised address. function main () var owner = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var authorised = State < Address > ( \"owner\" ); authorised . set ( owner ); doSomething ( owner ); endfunction @ action function doSomething ( signer : Address ) if ( ! signer . signedTx ()) panic ( \"This address doesn't verify, stopping here.\" ); endif // Get the authorised address from the ledger var authorised_state = State < Address > ( \"owner\" ); var authorised_address = authorised_state . get (); if ( authorised_address != signer ) panic ( \"Incorrect address used to trigger\" ); endif // ... we're good to go, the signer of the TX is the stored authorised address... endfunction","title":"Verify an Address"},{"location":"etch-language/strings/","text":"Strings etch supports ASCII for string representation. Concatenation Concatenate strings like this: function main () var myString : String = \"hello\" ; var myInferredString = \"hello again\" ; var x : String = null ; printLn ( myString ); printLn ( myInferredString ); printLn ( myInferredString + \" \" + myString ); // printLn(myString + x); // runtime error: line xx: null reference endfunction Equality You can test strings for equality. function main () var myString1 : String = \"hello\" ; var myString2 : String = \"hello\" ; if ( myString1 == myString2 ) printLn ( \"They are equal.\" ); else printLn ( \"They are not equal.\" ); endif endfunction And inequality. function main () var myString1 : String = \"hello\" ; var myString2 : String = \"again\" ; if ( myString1 != myString2 ) printLn ( \"They are not equal.\" ); else printLn ( \"They are equal.\" ); endif endfunction You can do a less than comparison on equal and unequal length strings. function main () // with regards to character var myString1 : String = \"a\" ; var myString2 : String = \"b\" ; // with regards to length of string // var myString1 : String = \"aa\"; // var myString2 : String = \"a\"; if ( myString1 < myString2 ) printLn ( \"myString1 is less than myString2.\" ); else printLn ( \"myString1 is not less than myString2.\" ); endif endfunction And a less than or equal to comparison on equal and unequal length strings. function main () // with regards to character var myString1 : String = \"a\" ; var myString2 : String = \"b\" ; // with regards to length of string // var myString1 : String = \"aa\"; // var myString2 : String = \"a\"; if ( myString1 <= myString2 ) printLn ( \"myString1 is less than or equal to myString2.\" ); else printLn ( \"myString1 is not less or equal to than myString2.\" ); endif endfunction You can calculate greater than between two equal or unequal length strings. function main () // with regards to character var myString1 : String = \"a\" ; var myString2 : String = \"b\" ; // with regards to length of string // var myString1 : String = \"aa\"; // var myString2 : String = \"a\"; if ( myString1 > myString2 ) printLn ( \"myString1 is greater than or equal to myString2.\" ); else printLn ( \"myString1 is not greater than or equal to myString2.\" ); endif endfunction And greater than or equal to also. function main () var myString1 : String = \"a\" ; var myString2 : String = \"a\" ; if ( myString1 >= myString2 ) printLn ( \"myString1 is greater than or equal to myString2.\" ); else printLn ( \"myString1 is not greater than or equal to myString2.\" ); endif endfunction String functions You can use the following utility functions for string manipulation: Find The find() function searches a string for the first occurrence of a specified substring. The search is case sensitive. The first character in the string occurs at index 0. Returns the index of the first occurrence of the substring. Returns -1 if the substring is not found. Returns -1 if either the string or the substring are empty. function main () var myString : String = \"Hello World\" ; printLn ( myString . find ( \"o\" )); endfunction Length The length() function returns the number of characters in a string. Returns -1 if the string is empty. function main () var myString : String = \"Hello World\" ; printLn ( myString . length ()); endfunction Reverse The reverse() function reverses the order of characters in a string. function main () var myString : String = \"xyz\" ; myString . reverse (); printLn ( myString ); endfunction Substring The substr() function extracts a substring from a string, based on specified starting and ending indices (but excluding the final character): string.substr(start, end) The start character in the string occurs at index 0. The end character is excluded from the substring. Returns an empty string if start and end indices are equal. Returns the whole string if start equals 0 and end is equal to the length of the string. Fails if start is greater than end . Fails if start is negative. Fails if end is greater than the length of the string. function main () printLn ( \"Hello World\" . substr ( 6 , 11 )); endfunction Trim The trim() function removes any whitespace from the start and end of a string. Returns an empty string if the original string contains only whitespace. function main () var myString : String = \" Hello World \" ; myString . trim (); printLn ( myString ); endfunction Split The split() function takes an input string and a character(s) sequence separator to split on and returns an array of strings that does not include the separator. Returns a one element array if there is no separator within it or if the input string is empty. Returns an empty string if more than one separator is encountered consecutively. Returns an empty string as the first element in the output array if the first element of the input is a separator. Returns an empty string as the last element in the output array if the last element of the input is a separator. The following code takes a string and splits it on the separator -- returning an array of strings which it then outputs. function main () var text = ' xxx -- yyy -- zzz ' ; printLn ( text ); var output = text . split ( ' -- ' ); printLn ( output [ 0 ]); printLn ( output [ 1 ]); printLn ( output [ 2 ]); endfunction","title":"Strings"},{"location":"etch-language/strings/#concatenation","text":"Concatenate strings like this: function main () var myString : String = \"hello\" ; var myInferredString = \"hello again\" ; var x : String = null ; printLn ( myString ); printLn ( myInferredString ); printLn ( myInferredString + \" \" + myString ); // printLn(myString + x); // runtime error: line xx: null reference endfunction","title":"Concatenation"},{"location":"etch-language/strings/#equality","text":"You can test strings for equality. function main () var myString1 : String = \"hello\" ; var myString2 : String = \"hello\" ; if ( myString1 == myString2 ) printLn ( \"They are equal.\" ); else printLn ( \"They are not equal.\" ); endif endfunction And inequality. function main () var myString1 : String = \"hello\" ; var myString2 : String = \"again\" ; if ( myString1 != myString2 ) printLn ( \"They are not equal.\" ); else printLn ( \"They are equal.\" ); endif endfunction You can do a less than comparison on equal and unequal length strings. function main () // with regards to character var myString1 : String = \"a\" ; var myString2 : String = \"b\" ; // with regards to length of string // var myString1 : String = \"aa\"; // var myString2 : String = \"a\"; if ( myString1 < myString2 ) printLn ( \"myString1 is less than myString2.\" ); else printLn ( \"myString1 is not less than myString2.\" ); endif endfunction And a less than or equal to comparison on equal and unequal length strings. function main () // with regards to character var myString1 : String = \"a\" ; var myString2 : String = \"b\" ; // with regards to length of string // var myString1 : String = \"aa\"; // var myString2 : String = \"a\"; if ( myString1 <= myString2 ) printLn ( \"myString1 is less than or equal to myString2.\" ); else printLn ( \"myString1 is not less or equal to than myString2.\" ); endif endfunction You can calculate greater than between two equal or unequal length strings. function main () // with regards to character var myString1 : String = \"a\" ; var myString2 : String = \"b\" ; // with regards to length of string // var myString1 : String = \"aa\"; // var myString2 : String = \"a\"; if ( myString1 > myString2 ) printLn ( \"myString1 is greater than or equal to myString2.\" ); else printLn ( \"myString1 is not greater than or equal to myString2.\" ); endif endfunction And greater than or equal to also. function main () var myString1 : String = \"a\" ; var myString2 : String = \"a\" ; if ( myString1 >= myString2 ) printLn ( \"myString1 is greater than or equal to myString2.\" ); else printLn ( \"myString1 is not greater than or equal to myString2.\" ); endif endfunction","title":"Equality"},{"location":"etch-language/strings/#string-functions","text":"You can use the following utility functions for string manipulation:","title":"String functions"},{"location":"etch-language/strings/#find","text":"The find() function searches a string for the first occurrence of a specified substring. The search is case sensitive. The first character in the string occurs at index 0. Returns the index of the first occurrence of the substring. Returns -1 if the substring is not found. Returns -1 if either the string or the substring are empty. function main () var myString : String = \"Hello World\" ; printLn ( myString . find ( \"o\" )); endfunction","title":"Find"},{"location":"etch-language/strings/#length","text":"The length() function returns the number of characters in a string. Returns -1 if the string is empty. function main () var myString : String = \"Hello World\" ; printLn ( myString . length ()); endfunction","title":"Length"},{"location":"etch-language/strings/#reverse","text":"The reverse() function reverses the order of characters in a string. function main () var myString : String = \"xyz\" ; myString . reverse (); printLn ( myString ); endfunction","title":"Reverse"},{"location":"etch-language/strings/#substring","text":"The substr() function extracts a substring from a string, based on specified starting and ending indices (but excluding the final character): string.substr(start, end) The start character in the string occurs at index 0. The end character is excluded from the substring. Returns an empty string if start and end indices are equal. Returns the whole string if start equals 0 and end is equal to the length of the string. Fails if start is greater than end . Fails if start is negative. Fails if end is greater than the length of the string. function main () printLn ( \"Hello World\" . substr ( 6 , 11 )); endfunction","title":"Substring"},{"location":"etch-language/strings/#trim","text":"The trim() function removes any whitespace from the start and end of a string. Returns an empty string if the original string contains only whitespace. function main () var myString : String = \" Hello World \" ; myString . trim (); printLn ( myString ); endfunction","title":"Trim"},{"location":"etch-language/strings/#split","text":"The split() function takes an input string and a character(s) sequence separator to split on and returns an array of strings that does not include the separator. Returns a one element array if there is no separator within it or if the input string is empty. Returns an empty string if more than one separator is encountered consecutively. Returns an empty string as the first element in the output array if the first element of the input is a separator. Returns an empty string as the last element in the output array if the last element of the input is a separator. The following code takes a string and splits it on the separator -- returning an array of strings which it then outputs. function main () var text = ' xxx -- yyy -- zzz ' ; printLn ( text ); var output = text . split ( ' -- ' ); printLn ( output [ 0 ]); printLn ( output [ 1 ]); printLn ( output [ 2 ]); endfunction","title":"Split"},{"location":"etch-language/syntax/","text":"Syntax The etch language integrates with the Fetch.AI Ledger project. It is designed to run on a number of platforms. etch is inspired by Rust, C++, and Python, but it also has some idiosyncrasies. The etch language is extremely restrictive to avoid costly errors on the ledger. See Smart Contract section for more information. etch is a statically typed language and static typing is enforced by the compiler. Note Blocks of code require no delimiters. White space is ignored. Indentation is recommended. You can extend and customise etch in C++. We show you how to do that here . Let's take a closer look at etch . Declarations Explicitly declare the type: function main () var myvariable : String ; endfunction In some cases, type can be inferred: function main () var myvariable = \"hello\" ; endfunction Assign a value like this: function main () var myvariable : String = \"hello\" ; endfunction For multivariate types, all the types must be declared: var multitype - variable - name : Type < Type < Type >> (); Not declaring the variable type and inferrable value results in a compilation error: function main () var myVariable ; endfunction Failed to compile . line 3 : error at ';' , expected ':' or '=' Failed to compile . Main Initially, all our code snippets execute inside the main function: function main () // stuff endfunction Keywords Here is a current list of etch keywords: var if endif else for endfor while endwhile function endfunction break continue return @init @action @query Comments Both line and block comments are possible: // a single comment inside a function /* ..lines of commented out stuff inside and outside functions */ Annotations etch code for smart contracts includes annotated functions. These are more like Java method annotations and not at all like Python decorators: @init is a constructor method that initialises the contract. @action is a function which defines transactions on the ledger that change state. @query is a function that allows you to query data residing on the ledger. We tell you all about these functions and more in the section on smart contracts .","title":"Syntax"},{"location":"etch-language/syntax/#declarations","text":"Explicitly declare the type: function main () var myvariable : String ; endfunction In some cases, type can be inferred: function main () var myvariable = \"hello\" ; endfunction Assign a value like this: function main () var myvariable : String = \"hello\" ; endfunction For multivariate types, all the types must be declared: var multitype - variable - name : Type < Type < Type >> (); Not declaring the variable type and inferrable value results in a compilation error: function main () var myVariable ; endfunction Failed to compile . line 3 : error at ';' , expected ':' or '=' Failed to compile .","title":"Declarations"},{"location":"etch-language/syntax/#main","text":"Initially, all our code snippets execute inside the main function: function main () // stuff endfunction","title":"Main"},{"location":"etch-language/syntax/#keywords","text":"Here is a current list of etch keywords: var if endif else for endfor while endwhile function endfunction break continue return @init @action @query","title":"Keywords"},{"location":"etch-language/syntax/#comments","text":"Both line and block comments are possible: // a single comment inside a function /* ..lines of commented out stuff inside and outside functions */","title":"Comments"},{"location":"etch-language/syntax/#annotations","text":"etch code for smart contracts includes annotated functions. These are more like Java method annotations and not at all like Python decorators: @init is a constructor method that initialises the contract. @action is a function which defines transactions on the ledger that change state. @query is a function that allows you to query data residing on the ledger. We tell you all about these functions and more in the section on smart contracts .","title":"Annotations"},{"location":"etch-language/variables/","text":"Variables etch is a statically-typed programming language. Declare a variable with the keyword var . Declare numeric values with literals where possible. You can also use an explicit type cast operation. See below for explicit type declaration rules. Naming Variable naming follows the same rules as C++. function main () var ABC = 1 ; var abc = 2 ; var _abc = 3 ; // var *abc = 4; // error at '*', expected variable name // var 123 = 5; // error at '123', expected variable name var a123 = 6 ; var a_123 = 7 ; endfunction Integers Integers can be signed or unsigned and are currently restricted to the width range 8-256 bits (1 to 32 bytes). They are declared as signed Int8 , Int16 , Int32 , Int64 , and unsigned UInt8 , UInt16 , UInt32 , UInt64 , UInt256 . Further, and in the same order, they can be declared with postfix literals i8 , i16 , i32 , i64 , u8 , u16 , u32 , and u64 . The UInt256 label will be supplied in a future version. Int32 is the compiler default so you don't need to explicitly declare this type. Below is a selection of example integer assignations. function main () // default signed 32 bit integer type var int32bit_default = 42 ; // declaring the variable type var int32bit : Int32 = - 43 ; printLn ( toString ( int32bit_default )); printLn ( toString ( int32bit )); endfunction function main () // assigning various signed integer types explicitly and with label var int8a = 0 i8 ; printLn ( toString ( int8a )); var int8b : Int8 = - 0 i8 ; printLn ( toString ( int8b )); var int16a = 0 i16 ; printLn ( toString ( int16a )); var int16b : Int16 = - 1 i16 ; printLn ( toString ( int16b )); endfunction function main () // Int32 is default but can be explicit also var int32a = 0 i32 ; printLn ( toString ( int32a )); var int32b : Int32 = - 1 i32 ; printLn ( toString ( int32b )); var int64a = 0 i64 ; printLn ( toString ( int64a )); var int64b : Int64 = - 1 i64 ; printLn ( toString ( int64b )); endfunction function main () // assigning various unsigned integer types var uint8a = 45u8 ; printLn ( toString ( uint8a )); var uint8b : UInt8 = 1u8 ; printLn ( toString ( uint8b )); var uint16a = 0u16 ; printLn ( toString ( uint16a )); var uint16b : UInt16 = 1u16 ; printLn ( toString ( uint16b )); endfunction function main () // assigning various unsigned integer types var uint32a = 0u32 ; printLn ( toString ( uint32a )); var uint32b : UInt32 = 1u32 ; printLn ( toString ( uint32b )); var uint64a = 0u64 ; printLn ( toString ( uint64a )); var uint64b : UInt64 = 1u64 ; printLn ( toString ( uint64b )); endfunction 32 byte unsigned integer Build a UInt256 from a UInt64 literal, like this: function main () var uint256 = UInt256 ( 100u64 ); printLn ( toString ( uint256 )); endfunction UInt256 variables are printed in hexadecimal for brevity. Floats Signed and unsigned decimal numbers are available as floating point types in 32 and 64 bit representation (4 and 8 bytes). Float types are declared as Float32 , Float64 . Unspecified floats default to Float64 . A Float declared with f is a Float32 . function main () // default 64 bit float declaration var float64bit_default = 64.0 ; // 64 bit type declaration var float64bit : Float64 = 64.0 ; printLn ( toString ( float64bit_default )); printLn ( toString ( float64bit )); // var float32bit : Float32 = 32.0; // error: incompatible types // declare 32 bit float with `f` var float32bit = 32.0f ; printLn ( toString ( float32bit )); endfunction Fixed Points Fixed point variables are available as Fixed32 and Fixed64 types. You must declare FixedPoint variables with the postfix literals fp32 and fp64 . function main () var fixed32bit : Fixed32 = 32.1f p32 ; var fixed64bit : Fixed64 = 64.1f p64 ; printLn ( toString ( fixed32bit )); printLn ( toString ( fixed64bit )); endfunction For brevity, you do not need the full declaration. function main () var fixed32bit = 2.0f p32 ; var fixed64bit = 3.0f p64 ; printLn ( toString ( fixed32bit )); printLn ( toString ( fixed64bit )); endfunction Boolean Declare and initialise Bool types as follows: function main () var myFBool : Bool = false ; var myTBool : Bool = true ; printLn ( toString ( myFBool )); printLn ( toString ( myTBool )); endfunction Strings Declare and initialise strings as follows: function main () var myString : String = \"hello\" ; var myInferredString = \"hello again\" ; var x : String = null ; printLn ( myString ); printLn ( myInferredString ); printLn ( myInferredString + \" \" + myString ); printLn ( x ); endfunction Find out more about etch Strings here . Arrays You must explicitly declare array element types and array size. Array<Type>(size) declares an array with elements of type Type and size size . function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; printLn ( toString ( myArray [ 3 ])); for ( i in 0 : 5 ) printLn ( toString ( myArray [ i ])); endfor printLn ( myArray ); endfunction Find out more about etch Arrays here . Buffer Create a Buffer byte array type like this, where the Buffer size is defined by a UInt32 type. function main () var myBuffer = Buffer ( 8 ); endfunction Currently, a Buffer is the medium for transport/exchange of data between other types, such as SHA256 and UInt256 . A parallel representation is the Array<UInt8> type. Maps Declare the dictionary Map type with Map<KeyType, ValueType>() . The function count() returns an Int32 value representing the number of entries in the Map . function main () var myMap = Map < String , Int32 > (); myMap [ \"balance1\" ] = 1000 ; myMap [ \"balance2\" ] = 2000 ; myMap [ \"balance3\" ] = 3000 ; printLn ( toString ( myMap [ \"balance1\" ])); printLn ( toString ( myMap [ \"balance2\" ])); printLn ( toString ( myMap [ \"balance3\" ])); printLn ( toString ( myMap . count ())); endfunction Note Coming soon: common Map operations. StructuredData A StructuredData type is another map type containing key/value pairs. Declare a StructuredData type with StructuredData() . The StructuredData type has no appreciable size limit. Keys must be strings. Duplicate keys are allowed and override the most recent entry. Values can be any primitive, string, or array of primitives. An important difference to the Map type is that a StructuredData type can generate yaml , json , or similar. function main () var data = StructuredData (); data . set ( \"key1\" , 200 i32 ); data . set ( \"key2\" , 500u64 ); data . set ( \"key3\" , \"hello world\" ); printLn ( toString ( data . getInt32 ( \"key1\" ))); printLn ( toString ( data . getUInt64 ( \"key2\" ))); printLn ( data . getString ( \"key3\" )); endfunction State A State is a data structure used by etch smart contracts for storing and querying data on the Fetch.AI Ledger shards. Unique identifiers for the ledger data are created at State construction time. These are unique to the smart contract alone. Declare and initialise a State type with State<ValueType>(\"ledger_identifier\") . function main () var myState = State<Int32> ( \"account\" ) ; endfunction Getters and setters are available for State types. In the example, values set with the set() function map to the unique ledger identifier account . function main () var myState = State < Int32 > ( \"account\" ); myState . set ( 10 ); printLn ( \"My state var value = \" + toString ( myState . get ())); endfunction Find out more about etch States here . ShardedState Like State , a ShardedState is also used for reading and writing data to the Fetch.AI Ledger. ShardedState manipulates State types behind the scenes but, for etch programmer purposes, a ShardedState operates like a Map with key/vlue pairs. Keys must be either String or Address types. Value types must be declared at construction time. Declare and initialise a ShardedState with ShardedState<ValueType>(\"ledger_identifier\") . Call set() on it to create a key/value pair. Print a value using get() with a key and a default value. function main () var myShardedState = ShardedState < Int32 > ( \"account1\" ); myShardedState . set ( \"salary\" , 45000 i32 ); printLn ( toString ( myShardedState . get ( \"salary\" , 0 i32 ))); endfunction Find out more about etch ShardedStates here . Address The cryptographic Address type is currently represented by a 64 byte binary canonical ECDSA public key which is then base 58 encoded. Declare and initialise an Address like this: function main () var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); endfunction Find out more about the etch Address type here . Mathematical, ML, and AI etch provides powerful mathematical, machine learning, and AI specific data types and functions. For more details on the mathematical computation functions above, please check the section on maths functions here . For more details on the machine learning implementations, please check the section on machine learning functions here . Type casting There is no implicit type casting in etch . If you need a specific non-default numerical type, you can make an explicit cast of the default Int32 and Float64 types. Use to<Type>Name(variable_to_cast) . function main () // signed 32 bit integer type var int32bit = 42 ; // cast to Int8 var int8Variable = toInt8 ( int32bit ); // cast to Int16 var int16Variable = toInt16 ( int32bit ); // cast to Int64 var int64Variable = toInt64 ( int32bit ); // cast to UInt8 var uint8Variable = toUInt8 ( int32bit ); // cast to UInt16 var uint16Variable = toUInt16 ( int32bit ); // cast to UInt32 var uint32Variable = toUInt32 ( int32bit ); // cast to UInt64 var uint64Variable = toUInt64 ( int32bit ); // cast to UInt256 // var uint256Variable = toUInt256(int32bit); // coming soon // float casting var float64bit = 42.0 ; // cast Float64 to Int32 var intFVariable = toInt32 ( float64bit ); // cast Float64 to Float32 var float32Variable = toFloat32 ( float64bit ); // cast Int32 to Float64 var float64variable = toFloat64 ( int32bit ); // fixed point casting var fixed32 : Fixed32 = 32.1f p32 ; var fixed64 : Fixed64 = 64.1f p64 ; // cast Fixed32 to Int32 var int32var = toInt32 ( fixed32 ); // cast Fixed64 to Fixed32 var fixed32Variable = toFixed32 ( fixed64 ); // cast Int32 to Fixed64 var fixed64variable = toFixed64 ( int32bit ); // cast to string var stringVariable = toString ( int32bit ); endfunction Data size In the table below, we detail the memory size of each data type. Type Memory size Int8 1 byte Int16 2 bytes Int32 4 bytes Int64 8 bytes UInt8 1 byte UInt16 2 bytes UInt32 4 bytes UInt64 8 bytes UInt256 32 bytes Float32 4 bytes Float64 8 bytes Bool 1 byte String 8 bytes + length character size (changing with UTF-8) Array 8 bytes + length x element size Map 8 bytes + n x (key + value) storage StructuredData tbc State tbc ShardedState tbc Address 32 bytes Currently, there is a 2 unit charge per 1 byte of ledger storage. Scope etch has no global variables. However, values store on the Fetch.AI Ledger can be considered global. Null Non-primitives can be set to null. function main () // var myInt = null ; // error: unable to infer type var str : String = null ; var myArray : Array < Int32 > = null ; var myMap : Map < Int32 , Int32 > = null ; var myState : State < Int32 > = null ; var myAddress : Address = null ; var myString : String = null ; printLn ( myString ); // (nullptr) endfunction Default values Certain types not explicitly initialised receive a default value. Type Default value Int8 tbc Int16 tbc Int32 0 Int64 0 UInt8 tbc UInt16 tbc UInt32 0 UInt64 0 UInt256 tbc Float32 0.000000 Float64 0.000000 Bool false String no default","title":"Variables"},{"location":"etch-language/variables/#naming","text":"Variable naming follows the same rules as C++. function main () var ABC = 1 ; var abc = 2 ; var _abc = 3 ; // var *abc = 4; // error at '*', expected variable name // var 123 = 5; // error at '123', expected variable name var a123 = 6 ; var a_123 = 7 ; endfunction","title":"Naming"},{"location":"etch-language/variables/#integers","text":"Integers can be signed or unsigned and are currently restricted to the width range 8-256 bits (1 to 32 bytes). They are declared as signed Int8 , Int16 , Int32 , Int64 , and unsigned UInt8 , UInt16 , UInt32 , UInt64 , UInt256 . Further, and in the same order, they can be declared with postfix literals i8 , i16 , i32 , i64 , u8 , u16 , u32 , and u64 . The UInt256 label will be supplied in a future version. Int32 is the compiler default so you don't need to explicitly declare this type. Below is a selection of example integer assignations. function main () // default signed 32 bit integer type var int32bit_default = 42 ; // declaring the variable type var int32bit : Int32 = - 43 ; printLn ( toString ( int32bit_default )); printLn ( toString ( int32bit )); endfunction function main () // assigning various signed integer types explicitly and with label var int8a = 0 i8 ; printLn ( toString ( int8a )); var int8b : Int8 = - 0 i8 ; printLn ( toString ( int8b )); var int16a = 0 i16 ; printLn ( toString ( int16a )); var int16b : Int16 = - 1 i16 ; printLn ( toString ( int16b )); endfunction function main () // Int32 is default but can be explicit also var int32a = 0 i32 ; printLn ( toString ( int32a )); var int32b : Int32 = - 1 i32 ; printLn ( toString ( int32b )); var int64a = 0 i64 ; printLn ( toString ( int64a )); var int64b : Int64 = - 1 i64 ; printLn ( toString ( int64b )); endfunction function main () // assigning various unsigned integer types var uint8a = 45u8 ; printLn ( toString ( uint8a )); var uint8b : UInt8 = 1u8 ; printLn ( toString ( uint8b )); var uint16a = 0u16 ; printLn ( toString ( uint16a )); var uint16b : UInt16 = 1u16 ; printLn ( toString ( uint16b )); endfunction function main () // assigning various unsigned integer types var uint32a = 0u32 ; printLn ( toString ( uint32a )); var uint32b : UInt32 = 1u32 ; printLn ( toString ( uint32b )); var uint64a = 0u64 ; printLn ( toString ( uint64a )); var uint64b : UInt64 = 1u64 ; printLn ( toString ( uint64b )); endfunction","title":"Integers"},{"location":"etch-language/variables/#32-byte-unsigned-integer","text":"Build a UInt256 from a UInt64 literal, like this: function main () var uint256 = UInt256 ( 100u64 ); printLn ( toString ( uint256 )); endfunction UInt256 variables are printed in hexadecimal for brevity.","title":"32 byte unsigned integer"},{"location":"etch-language/variables/#floats","text":"Signed and unsigned decimal numbers are available as floating point types in 32 and 64 bit representation (4 and 8 bytes). Float types are declared as Float32 , Float64 . Unspecified floats default to Float64 . A Float declared with f is a Float32 . function main () // default 64 bit float declaration var float64bit_default = 64.0 ; // 64 bit type declaration var float64bit : Float64 = 64.0 ; printLn ( toString ( float64bit_default )); printLn ( toString ( float64bit )); // var float32bit : Float32 = 32.0; // error: incompatible types // declare 32 bit float with `f` var float32bit = 32.0f ; printLn ( toString ( float32bit )); endfunction","title":"Floats"},{"location":"etch-language/variables/#fixed-points","text":"Fixed point variables are available as Fixed32 and Fixed64 types. You must declare FixedPoint variables with the postfix literals fp32 and fp64 . function main () var fixed32bit : Fixed32 = 32.1f p32 ; var fixed64bit : Fixed64 = 64.1f p64 ; printLn ( toString ( fixed32bit )); printLn ( toString ( fixed64bit )); endfunction For brevity, you do not need the full declaration. function main () var fixed32bit = 2.0f p32 ; var fixed64bit = 3.0f p64 ; printLn ( toString ( fixed32bit )); printLn ( toString ( fixed64bit )); endfunction","title":"Fixed Points"},{"location":"etch-language/variables/#boolean","text":"Declare and initialise Bool types as follows: function main () var myFBool : Bool = false ; var myTBool : Bool = true ; printLn ( toString ( myFBool )); printLn ( toString ( myTBool )); endfunction","title":"Boolean"},{"location":"etch-language/variables/#strings","text":"Declare and initialise strings as follows: function main () var myString : String = \"hello\" ; var myInferredString = \"hello again\" ; var x : String = null ; printLn ( myString ); printLn ( myInferredString ); printLn ( myInferredString + \" \" + myString ); printLn ( x ); endfunction Find out more about etch Strings here .","title":"Strings"},{"location":"etch-language/variables/#arrays","text":"You must explicitly declare array element types and array size. Array<Type>(size) declares an array with elements of type Type and size size . function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; printLn ( toString ( myArray [ 3 ])); for ( i in 0 : 5 ) printLn ( toString ( myArray [ i ])); endfor printLn ( myArray ); endfunction Find out more about etch Arrays here .","title":"Arrays"},{"location":"etch-language/variables/#buffer","text":"Create a Buffer byte array type like this, where the Buffer size is defined by a UInt32 type. function main () var myBuffer = Buffer ( 8 ); endfunction Currently, a Buffer is the medium for transport/exchange of data between other types, such as SHA256 and UInt256 . A parallel representation is the Array<UInt8> type.","title":"Buffer"},{"location":"etch-language/variables/#maps","text":"Declare the dictionary Map type with Map<KeyType, ValueType>() . The function count() returns an Int32 value representing the number of entries in the Map . function main () var myMap = Map < String , Int32 > (); myMap [ \"balance1\" ] = 1000 ; myMap [ \"balance2\" ] = 2000 ; myMap [ \"balance3\" ] = 3000 ; printLn ( toString ( myMap [ \"balance1\" ])); printLn ( toString ( myMap [ \"balance2\" ])); printLn ( toString ( myMap [ \"balance3\" ])); printLn ( toString ( myMap . count ())); endfunction Note Coming soon: common Map operations.","title":"Maps"},{"location":"etch-language/variables/#structureddata","text":"A StructuredData type is another map type containing key/value pairs. Declare a StructuredData type with StructuredData() . The StructuredData type has no appreciable size limit. Keys must be strings. Duplicate keys are allowed and override the most recent entry. Values can be any primitive, string, or array of primitives. An important difference to the Map type is that a StructuredData type can generate yaml , json , or similar. function main () var data = StructuredData (); data . set ( \"key1\" , 200 i32 ); data . set ( \"key2\" , 500u64 ); data . set ( \"key3\" , \"hello world\" ); printLn ( toString ( data . getInt32 ( \"key1\" ))); printLn ( toString ( data . getUInt64 ( \"key2\" ))); printLn ( data . getString ( \"key3\" )); endfunction","title":"StructuredData"},{"location":"etch-language/variables/#state","text":"A State is a data structure used by etch smart contracts for storing and querying data on the Fetch.AI Ledger shards. Unique identifiers for the ledger data are created at State construction time. These are unique to the smart contract alone. Declare and initialise a State type with State<ValueType>(\"ledger_identifier\") . function main () var myState = State<Int32> ( \"account\" ) ; endfunction Getters and setters are available for State types. In the example, values set with the set() function map to the unique ledger identifier account . function main () var myState = State < Int32 > ( \"account\" ); myState . set ( 10 ); printLn ( \"My state var value = \" + toString ( myState . get ())); endfunction Find out more about etch States here .","title":"State"},{"location":"etch-language/variables/#shardedstate","text":"Like State , a ShardedState is also used for reading and writing data to the Fetch.AI Ledger. ShardedState manipulates State types behind the scenes but, for etch programmer purposes, a ShardedState operates like a Map with key/vlue pairs. Keys must be either String or Address types. Value types must be declared at construction time. Declare and initialise a ShardedState with ShardedState<ValueType>(\"ledger_identifier\") . Call set() on it to create a key/value pair. Print a value using get() with a key and a default value. function main () var myShardedState = ShardedState < Int32 > ( \"account1\" ); myShardedState . set ( \"salary\" , 45000 i32 ); printLn ( toString ( myShardedState . get ( \"salary\" , 0 i32 ))); endfunction Find out more about etch ShardedStates here .","title":"ShardedState"},{"location":"etch-language/variables/#address","text":"The cryptographic Address type is currently represented by a 64 byte binary canonical ECDSA public key which is then base 58 encoded. Declare and initialise an Address like this: function main () var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); endfunction Find out more about the etch Address type here .","title":"Address"},{"location":"etch-language/variables/#mathematical-ml-and-ai","text":"etch provides powerful mathematical, machine learning, and AI specific data types and functions. For more details on the mathematical computation functions above, please check the section on maths functions here . For more details on the machine learning implementations, please check the section on machine learning functions here .","title":"Mathematical, ML, and AI"},{"location":"etch-language/variables/#type-casting","text":"There is no implicit type casting in etch . If you need a specific non-default numerical type, you can make an explicit cast of the default Int32 and Float64 types. Use to<Type>Name(variable_to_cast) . function main () // signed 32 bit integer type var int32bit = 42 ; // cast to Int8 var int8Variable = toInt8 ( int32bit ); // cast to Int16 var int16Variable = toInt16 ( int32bit ); // cast to Int64 var int64Variable = toInt64 ( int32bit ); // cast to UInt8 var uint8Variable = toUInt8 ( int32bit ); // cast to UInt16 var uint16Variable = toUInt16 ( int32bit ); // cast to UInt32 var uint32Variable = toUInt32 ( int32bit ); // cast to UInt64 var uint64Variable = toUInt64 ( int32bit ); // cast to UInt256 // var uint256Variable = toUInt256(int32bit); // coming soon // float casting var float64bit = 42.0 ; // cast Float64 to Int32 var intFVariable = toInt32 ( float64bit ); // cast Float64 to Float32 var float32Variable = toFloat32 ( float64bit ); // cast Int32 to Float64 var float64variable = toFloat64 ( int32bit ); // fixed point casting var fixed32 : Fixed32 = 32.1f p32 ; var fixed64 : Fixed64 = 64.1f p64 ; // cast Fixed32 to Int32 var int32var = toInt32 ( fixed32 ); // cast Fixed64 to Fixed32 var fixed32Variable = toFixed32 ( fixed64 ); // cast Int32 to Fixed64 var fixed64variable = toFixed64 ( int32bit ); // cast to string var stringVariable = toString ( int32bit ); endfunction","title":"Type casting"},{"location":"etch-language/variables/#data-size","text":"In the table below, we detail the memory size of each data type. Type Memory size Int8 1 byte Int16 2 bytes Int32 4 bytes Int64 8 bytes UInt8 1 byte UInt16 2 bytes UInt32 4 bytes UInt64 8 bytes UInt256 32 bytes Float32 4 bytes Float64 8 bytes Bool 1 byte String 8 bytes + length character size (changing with UTF-8) Array 8 bytes + length x element size Map 8 bytes + n x (key + value) storage StructuredData tbc State tbc ShardedState tbc Address 32 bytes Currently, there is a 2 unit charge per 1 byte of ledger storage.","title":"Data size"},{"location":"etch-language/variables/#scope","text":"etch has no global variables. However, values store on the Fetch.AI Ledger can be considered global.","title":"Scope"},{"location":"etch-language/variables/#null","text":"Non-primitives can be set to null. function main () // var myInt = null ; // error: unable to infer type var str : String = null ; var myArray : Array < Int32 > = null ; var myMap : Map < Int32 , Int32 > = null ; var myState : State < Int32 > = null ; var myAddress : Address = null ; var myString : String = null ; printLn ( myString ); // (nullptr) endfunction","title":"Null"},{"location":"etch-language/variables/#default-values","text":"Certain types not explicitly initialised receive a default value. Type Default value Int8 tbc Int16 tbc Int32 0 Int64 0 UInt8 tbc UInt16 tbc UInt32 0 UInt64 0 UInt256 tbc Float32 0.000000 Float64 0.000000 Bool false String no default","title":"Default values"},{"location":"etch-language/examples/fetch-logo/","text":"Drawing the Fetch logo function main () // printLn ( \"Hello, everyone. Let's do some drawing.\" ); // // Some messing about to test something; the for range of 0:0 (start/end) means we // can't *not* iterate, which is worthy of discussion. for ( i in 0 : 0 ) // printLn(\"A-TEST: Wish we didn't see this - \" + toString(i)); endfor for ( i in 0 : 1 ) // printLn(\"B-TEST: And this should be once, but it's twice - \" + toString(i)); endfor // // Declare logo array (for string building) and the starting values: var fetchLogo = Array < Int32 > ( 64 * 64 ); var leftAmount : Int32 = 60 ; var rightAmount : Int32 = 0 ; // // Flip flop does an aspect ratio correction if enabled: var flipFlop : Bool = false ; var enableFlipFlop : Bool = true ; for ( y in 0 : 63 ) // // Reset the array line, then add left and right with space between: for ( i in 0 : 63 ) fetchLogo [ i ] = 0 ; endfor for ( leftBit in 0 : leftAmount ) fetchLogo [ leftBit ] = 1 ; endfor var cursor = leftAmount + 3 ; for ( rightBit in 0 : rightAmount ) // -- see discussion point in header fetchLogo [ cursor + rightBit ] = 1 ; endfor // // Adjust for next line: leftAmount -- ; rightAmount ++ ; // // Now render the line, skipping every other if we're in that // mode: if ( false == enableFlipFlop || ( enableFlipFlop && flipFlop )) var logoLine : String = \"\" ; for ( stringIndex in 0 : 63 ) if ( 0 == fetchLogo [ stringIndex ]) logoLine = logoLine + \" \" ; else logoLine = logoLine + \"*\" ; endif endfor printLn ( logoLine ); endif // // Invert flipflop for next iteration: flipFlop = ! flipFlop ; endfor endfunction","title":"Fetch logo"},{"location":"etch-language/examples/mandelbrot/","text":"Drawing the Mandelbrot set // TWS, April 28th, Mandelbrot Set (simple version): function main () // printLn ( \"Mandelbrot Set\" ); // // The \"screen\" size and the screen itself (double height for mirrored set): var xMax : Int32 = 100 ; var yMax : Int32 = 32 ; var halfOffset : Int32 = yMax * xMax ; var screen = Array < String > ( xMax * ( yMax * 2 )); var maxIterations : Int32 = 230 ; var maxSprites : Float64 = 32.0 ; // // Draw the mandelbrot set: for ( pixelY in 0 : yMax - 1 ) for ( pixelX in 0 : xMax - 1 ) // // Scale X to mandlebrot scale (x -2.5 to 1): var xLocal : Float64 = toFloat64 ( pixelX ); xLocal = (( xLocal / toFloat64 ( xMax )) * 3.5 ) - 2.5 ; // // Now Y to -1 to 1: var yLocal : Float64 = toFloat64 ( pixelY ); yLocal = yLocal / toFloat64 ( yMax ); // // Now let's do the algorithm bit: var x : Float64 = 0.0 ; var y : Float64 = 0.0 ; var iteration : Int32 = 0 ; while ((( x * x ) + ( y * y )) <= 4.0 && iteration < maxIterations ) var xTemp = ( x * x ) - ( y * y ) + xLocal ; y = 2.0 * x * y + yLocal ; x = xTemp ; iteration ++ ; endwhile // // Render based on iteration achieved: var colourSlide : Float64 = ( toFloat64 ( iteration ) / toFloat64 ( maxIterations )); var colourIndex : Int32 = toInt32 ( colourSlide * maxSprites ); // // Pick a character according to colourIndex (iterations achieved): var insertCharacter : String = \" \" ; if ( colourIndex < 2 ) insertCharacter = \" \" ; elseif ( colourIndex < 6 ) insertCharacter = \".\" ; elseif ( colourIndex < 10 ) insertCharacter = \"'\" ; elseif ( colourIndex < 20 ) insertCharacter = \"+\" ; else insertCharacter = \"*\" ; endif // // Bottom half of mandlebrot set: var bIndex : Int32 = halfOffset + ( pixelY * xMax ) + pixelX ; screen [ bIndex ] = insertCharacter ; // // Top mirror half: var inverseY = yMax - pixelY ; var tIndex : Int32 = ( inverseY * xMax ) + pixelX ; screen [ tIndex ] = insertCharacter ; endfor endfor // // Render the buffer out: for ( y in 0 : ( yMax * 2 ) - 1 ) var line : String = \"\" ; for ( x in 0 : xMax - 1 ) // // Build the line, deal with my own stupidity with the screen array // by testing for NULL: var index : Int32 = ( y * xMax ) + x ; if ( screen [ index ] == null ) line = line + \" \" ; else line = line + screen [ index ]; endif endfor // // Output this line and proceed to next: printLn ( line ); endfor endfunction","title":"Mandelbrot"},{"location":"etch-language/examples/searching-algorithms/","text":"Creating a search algorithm Linear search function main () var myArray = Array < Int32 >( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; var search_for = 48 ; var found : Bool ; found = linear_search ( myArray , search_for ); printLn ( toString ( search_for ) + \" is in the list? : \" + toString ( found )); endfunction function linear_search ( an_array : Array < Int32 >, search_for : Int32 ) : Bool var found : Bool = false ; for ( i in 0 : an_array . count ()- 1 ) if ( an_array [ i ] == search_for ) found = true ; endif endfor return found ; endfunction Binary search function main () var myArray = Array < Int32 >( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; var search_for = 40 ; var found : Bool ; found = binary_search ( myArray , search_for ); printLn ( toString ( search_for ) + \" is in the list? : \" + toString ( found )); endfunction function binary_search ( an_array : Array < Int32 >, search_for : Int32 ) : Bool var start = 0 ; var end = an_array . count (); var found : Bool = false ; while ( start <= end && found == false ) var midpoint = ( start + end ) / 2 ; if ( search_for == an_array [ midpoint ]) found = true ; elseif ( search_for < an_array [ midpoint ]) end = midpoint - 1 ; else start = midpoint + 1 ; endif endwhile return found ; endfunction","title":"Searching algorithms"},{"location":"etch-language/examples/searching-algorithms/#linear-search","text":"function main () var myArray = Array < Int32 >( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; var search_for = 48 ; var found : Bool ; found = linear_search ( myArray , search_for ); printLn ( toString ( search_for ) + \" is in the list? : \" + toString ( found )); endfunction function linear_search ( an_array : Array < Int32 >, search_for : Int32 ) : Bool var found : Bool = false ; for ( i in 0 : an_array . count ()- 1 ) if ( an_array [ i ] == search_for ) found = true ; endif endfor return found ; endfunction","title":"Linear search"},{"location":"etch-language/examples/searching-algorithms/#binary-search","text":"function main () var myArray = Array < Int32 >( 5 ); myArray [ 0 ] = 40 ; myArray [ 1 ] = 41 ; myArray [ 2 ] = 42 ; myArray [ 3 ] = 43 ; myArray [ 4 ] = 44 ; var search_for = 40 ; var found : Bool ; found = binary_search ( myArray , search_for ); printLn ( toString ( search_for ) + \" is in the list? : \" + toString ( found )); endfunction function binary_search ( an_array : Array < Int32 >, search_for : Int32 ) : Bool var start = 0 ; var end = an_array . count (); var found : Bool = false ; while ( start <= end && found == false ) var midpoint = ( start + end ) / 2 ; if ( search_for == an_array [ midpoint ]) found = true ; elseif ( search_for < an_array [ midpoint ]) end = midpoint - 1 ; else start = midpoint + 1 ; endif endwhile return found ; endfunction","title":"Binary search"},{"location":"etch-language/examples/sorting-algorithms/","text":"Designing a sorting algorithm Bubble sort function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 41 ; myArray [ 1 ] = 40 ; myArray [ 2 ] = 43 ; myArray [ 3 ] = 44 ; myArray [ 4 ] = 42 ; print ( \"Unsorted:\" ); for ( i in 0 : myArray . count ()) print ( toString ( myArray [ i ]) + \" \" ); endfor printLn ( \"\" ); bubble_sort ( myArray ); print ( \"Sorted:\" ); for ( i in 0 : myArray . count ()) print ( toString ( myArray [ i ]) + \" \" ); endfor printLn ( \"\" ); endfunction function bubble_sort ( an_array : Array < Int32 > ) var more_swaps : Bool = true ; while ( more_swaps == true ) more_swaps = false ; for ( i in 0 : an_array . count () - 1 ) if ( an_array [ i ] > an_array [ i + 1 ]) more_swaps = true ; var temp = an_array [ i ]; an_array [ i ] = an_array [ i + 1 ]; an_array [ i + 1 ] = temp ; endif endfor endwhile endfunction Insertion sort function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 41 ; myArray [ 1 ] = 40 ; myArray [ 2 ] = 43 ; myArray [ 3 ] = 44 ; myArray [ 4 ] = 42 ; print ( \"Unsorted:\" ); for ( i in 0 : myArray . count ()) print ( toString ( myArray [ i ]) + \" \" ); endfor printLn ( \"\" ); insertion_sort ( myArray ); print ( \"Sorted:\" ); for ( i in 0 : myArray . count ()) print ( toString ( myArray [ i ]) + \" \" ); endfor printLn ( \"\" ); endfunction function insertion_sort ( an_array : Array < Int32 > ) for ( index in 1 : an_array . count ()) var currentvalue = an_array [ index ]; var position = index ; while (( position > 1 ) && ( an_array [ position - 1 ] > currentvalue )) an_array [ position ] = an_array [ position - 1 ]; position = position - 1 ; endwhile an_array [ position ] = currentvalue ; endfor endfunction Merge sort function main () var a_list = Array < UInt32 > ( 15 ); for ( i in 0 : a_list . count ()) a_list [ i ] = rand ( 0u32 , 1000u32 ); endfor printLn ( a_list ); merge ( a_list ); printLn ( a_list ); endfunction function merge ( a_list : Array < UInt32 > ) // print ( \"Splitting \" ); printLn ( a_list ); if ( a_list . count () > 1 ) var initial_count = a_list . count (); var mid = a_list . count () / 2 ; var left_half = Array < UInt32 > ( mid ); var right_half = Array < UInt32 > ( a_list . count () - mid ); for ( x in 0 : mid ) left_half [ x ] = a_list [ x ]; endfor for ( y in mid : a_list . count ()) right_half [ y - mid ] = a_list [ y ]; endfor // print(\"Left half \"); printLn(left_half); // print(\"Right half \"); printLn(right_half); merge ( left_half ); merge ( right_half ); var i = 0 ; var j = 0 ; var k = 0 ; while ( i < left_half . count () && j < right_half . count ()) if ( left_half [ i ] < right_half [ j ]) a_list [ k ] = left_half [ i ]; i += 1 ; else a_list [ k ] = right_half [ j ]; j += 1 ; endif k = k + 1 ; endwhile while ( i < left_half . count ()) a_list [ k ] = left_half [ i ]; i += 1 ; k += 1 ; endwhile while ( j < right_half . count ()) a_list [ k ] = right_half [ j ]; j += 1 ; k += 1 ; endwhile endif //print(\"Merging \"); printLn(a_list); endfunction Quick sort Note Coming soon.","title":"Sorting algorithms"},{"location":"etch-language/examples/sorting-algorithms/#bubble-sort","text":"function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 41 ; myArray [ 1 ] = 40 ; myArray [ 2 ] = 43 ; myArray [ 3 ] = 44 ; myArray [ 4 ] = 42 ; print ( \"Unsorted:\" ); for ( i in 0 : myArray . count ()) print ( toString ( myArray [ i ]) + \" \" ); endfor printLn ( \"\" ); bubble_sort ( myArray ); print ( \"Sorted:\" ); for ( i in 0 : myArray . count ()) print ( toString ( myArray [ i ]) + \" \" ); endfor printLn ( \"\" ); endfunction function bubble_sort ( an_array : Array < Int32 > ) var more_swaps : Bool = true ; while ( more_swaps == true ) more_swaps = false ; for ( i in 0 : an_array . count () - 1 ) if ( an_array [ i ] > an_array [ i + 1 ]) more_swaps = true ; var temp = an_array [ i ]; an_array [ i ] = an_array [ i + 1 ]; an_array [ i + 1 ] = temp ; endif endfor endwhile endfunction","title":"Bubble sort"},{"location":"etch-language/examples/sorting-algorithms/#insertion-sort","text":"function main () var myArray = Array < Int32 > ( 5 ); myArray [ 0 ] = 41 ; myArray [ 1 ] = 40 ; myArray [ 2 ] = 43 ; myArray [ 3 ] = 44 ; myArray [ 4 ] = 42 ; print ( \"Unsorted:\" ); for ( i in 0 : myArray . count ()) print ( toString ( myArray [ i ]) + \" \" ); endfor printLn ( \"\" ); insertion_sort ( myArray ); print ( \"Sorted:\" ); for ( i in 0 : myArray . count ()) print ( toString ( myArray [ i ]) + \" \" ); endfor printLn ( \"\" ); endfunction function insertion_sort ( an_array : Array < Int32 > ) for ( index in 1 : an_array . count ()) var currentvalue = an_array [ index ]; var position = index ; while (( position > 1 ) && ( an_array [ position - 1 ] > currentvalue )) an_array [ position ] = an_array [ position - 1 ]; position = position - 1 ; endwhile an_array [ position ] = currentvalue ; endfor endfunction","title":"Insertion sort"},{"location":"etch-language/examples/sorting-algorithms/#merge-sort","text":"function main () var a_list = Array < UInt32 > ( 15 ); for ( i in 0 : a_list . count ()) a_list [ i ] = rand ( 0u32 , 1000u32 ); endfor printLn ( a_list ); merge ( a_list ); printLn ( a_list ); endfunction function merge ( a_list : Array < UInt32 > ) // print ( \"Splitting \" ); printLn ( a_list ); if ( a_list . count () > 1 ) var initial_count = a_list . count (); var mid = a_list . count () / 2 ; var left_half = Array < UInt32 > ( mid ); var right_half = Array < UInt32 > ( a_list . count () - mid ); for ( x in 0 : mid ) left_half [ x ] = a_list [ x ]; endfor for ( y in mid : a_list . count ()) right_half [ y - mid ] = a_list [ y ]; endfor // print(\"Left half \"); printLn(left_half); // print(\"Right half \"); printLn(right_half); merge ( left_half ); merge ( right_half ); var i = 0 ; var j = 0 ; var k = 0 ; while ( i < left_half . count () && j < right_half . count ()) if ( left_half [ i ] < right_half [ j ]) a_list [ k ] = left_half [ i ]; i += 1 ; else a_list [ k ] = right_half [ j ]; j += 1 ; endif k = k + 1 ; endwhile while ( i < left_half . count ()) a_list [ k ] = left_half [ i ]; i += 1 ; k += 1 ; endwhile while ( j < right_half . count ()) a_list [ k ] = right_half [ j ]; j += 1 ; k += 1 ; endwhile endif //print(\"Merging \"); printLn(a_list); endfunction","title":"Merge sort"},{"location":"etch-language/examples/sorting-algorithms/#quick-sort","text":"Note Coming soon.","title":"Quick sort"},{"location":"getting-started/installation-mac/","text":"Building the Fetch.AI components Currently, the Fetch.AI Ledger and the open economic framework (OEF) are built and deployed individually. This will change with the main net deployment towards the end of the year. Supported platforms MacOS Darwin 10.13x and higher (64bit) Initial setup Get homebrew: /usr/bin/ruby -e \" $( curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install ) \" Install dependencies: brew install cmake openssl git python Or with MacPorts: port install cmake openssl git python If you use homebrew , edit your ~/.bash_profile : export OPENSSL_ROOT_DIR = \"/usr/local/Cellar/openssl/`ls /usr/local/Cellar/openssl/ | sort | tail -1`\" Add the git alias: git config --global alias.pullall '!f(){ git pull \"$@\" && git submodule sync --recursive && git submodule update --init --recursive; }; f' Download the ledger code If you need them, here are the Git SSH key generation instructions. Clone the repository: cd [ working_directory ] git clone https://github.com/fetchai/ledger.git git checkout release/v0.6.x Update and initialise submodules from the repository root directory: cd ledger git pull git submodule update --init --recursive Make sure you have all the submodules: git submodule status If any submodules are missing, please check your installation. Build the ledger From the ledger directory, follow the steps to build the library: mkdir build cd build cmake .. make -j constellation You may have memory issues on make , so limit the number of cores (we chose 4): make -j 4 constellation If you want, you can build all the libraries: make -j 4 For the etch simulator, build the etch library: make etch Possible gotchas To avoid issues with OpenSSL, run the following: cmake -DOPENSSL_ROOT_DIR = /usr/local/ssl -DOPENSSL_LIBRARIES = /usr/local/ssl/lib","title":"MacOS"},{"location":"getting-started/installation-mac/#building-the-fetchai-components","text":"Currently, the Fetch.AI Ledger and the open economic framework (OEF) are built and deployed individually. This will change with the main net deployment towards the end of the year.","title":"Building the Fetch.AI components"},{"location":"getting-started/installation-mac/#supported-platforms","text":"MacOS Darwin 10.13x and higher (64bit)","title":"Supported platforms"},{"location":"getting-started/installation-mac/#initial-setup","text":"Get homebrew: /usr/bin/ruby -e \" $( curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install ) \" Install dependencies: brew install cmake openssl git python Or with MacPorts: port install cmake openssl git python If you use homebrew , edit your ~/.bash_profile : export OPENSSL_ROOT_DIR = \"/usr/local/Cellar/openssl/`ls /usr/local/Cellar/openssl/ | sort | tail -1`\" Add the git alias: git config --global alias.pullall '!f(){ git pull \"$@\" && git submodule sync --recursive && git submodule update --init --recursive; }; f'","title":"Initial setup"},{"location":"getting-started/installation-mac/#download-the-ledger-code","text":"If you need them, here are the Git SSH key generation instructions. Clone the repository: cd [ working_directory ] git clone https://github.com/fetchai/ledger.git git checkout release/v0.6.x Update and initialise submodules from the repository root directory: cd ledger git pull git submodule update --init --recursive Make sure you have all the submodules: git submodule status If any submodules are missing, please check your installation.","title":"Download the ledger code"},{"location":"getting-started/installation-mac/#build-the-ledger","text":"From the ledger directory, follow the steps to build the library: mkdir build cd build cmake .. make -j constellation You may have memory issues on make , so limit the number of cores (we chose 4): make -j 4 constellation If you want, you can build all the libraries: make -j 4 For the etch simulator, build the etch library: make etch","title":"Build the ledger"},{"location":"getting-started/installation-mac/#possible-gotchas","text":"To avoid issues with OpenSSL, run the following: cmake -DOPENSSL_ROOT_DIR = /usr/local/ssl -DOPENSSL_LIBRARIES = /usr/local/ssl/lib","title":"Possible gotchas"},{"location":"getting-started/installation-redhat/","text":"Building the Fetch.AI components Currently, the Fetch.AI Ledger and the open economic framework (OEF) are built and deployed invidually. This will change with the main net deployment towards the end of the year. Supported platforms Red Hat is not currently supported. Initial setup Set environment variables: export CC = clang export CXX = clang++ Install dependencies: yum install -y sudo yum install -y make yum install -y cmake yum install -y libpng-devel yum install -y zlib-devel yum install -y openssl-devel yum install -y python36-devel ( replace 36 with your version of Python3 ) yum install -y clang yum install -y epel-release ( dnf install https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm ) yum install -y python-pip ( prb. already installed ) yum install -y git pip2 install --upgrade pip pip3 install --upgrade pip pip install --upgrade cldoc yum install -y autoconf yum install -y automake yum install -y wget yum install -y which yum install -y tree Download the ledger code If you need them, here are the Git SSH key generation instructions. Clone the repository: cd [ working_directory ] git clone https://github.com/fetchai/ledger.git git checkout release/v0.6.x Update and initialise submodules from the repository root directory: cd ledger git pull git submodule update --init --recursive Make sure you have all the submodules: git submodule status If any submodules are missing, please check your installation. Build the ledger From the ledger directory, follow the steps to build the library: mkdir build cd build cmake .. make -j constellation You may have memory issues on make , so limit the number of cores (we chose 4): make -j 4 constellation If you want, you can build all the libraries: make -j 4 For the etch simulator, build the etch library: make etch","title":"Redhat"},{"location":"getting-started/installation-redhat/#building-the-fetchai-components","text":"Currently, the Fetch.AI Ledger and the open economic framework (OEF) are built and deployed invidually. This will change with the main net deployment towards the end of the year.","title":"Building the Fetch.AI components"},{"location":"getting-started/installation-redhat/#supported-platforms","text":"Red Hat is not currently supported.","title":"Supported platforms"},{"location":"getting-started/installation-redhat/#initial-setup","text":"Set environment variables: export CC = clang export CXX = clang++ Install dependencies: yum install -y sudo yum install -y make yum install -y cmake yum install -y libpng-devel yum install -y zlib-devel yum install -y openssl-devel yum install -y python36-devel ( replace 36 with your version of Python3 ) yum install -y clang yum install -y epel-release ( dnf install https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm ) yum install -y python-pip ( prb. already installed ) yum install -y git pip2 install --upgrade pip pip3 install --upgrade pip pip install --upgrade cldoc yum install -y autoconf yum install -y automake yum install -y wget yum install -y which yum install -y tree","title":"Initial setup"},{"location":"getting-started/installation-redhat/#download-the-ledger-code","text":"If you need them, here are the Git SSH key generation instructions. Clone the repository: cd [ working_directory ] git clone https://github.com/fetchai/ledger.git git checkout release/v0.6.x Update and initialise submodules from the repository root directory: cd ledger git pull git submodule update --init --recursive Make sure you have all the submodules: git submodule status If any submodules are missing, please check your installation.","title":"Download the ledger code"},{"location":"getting-started/installation-redhat/#build-the-ledger","text":"From the ledger directory, follow the steps to build the library: mkdir build cd build cmake .. make -j constellation You may have memory issues on make , so limit the number of cores (we chose 4): make -j 4 constellation If you want, you can build all the libraries: make -j 4 For the etch simulator, build the etch library: make etch","title":"Build the ledger"},{"location":"getting-started/installation-ubuntu/","text":"Building the Fetch.AI components Currently, the Fetch.AI Ledger and the open economic framework (OEF) are built and deployed invidually. This will change with the main net deployment towards the end of the year. Supported platforms Ubuntu 18.04 (x86_64) Initial setup Set environment variables in /etc/profile : export CC = clang export CXX = clang++ Update: sudo apt-get update Install dependencies: apt-get install build-essential clang git cmake libssl-dev doxygen python3-dev python3-pip python3-venv Update: sudo apt-get update Add the git alias: git config --global alias.pullall '!f(){ git pull \"$@\" && git submodule sync --recursive && git submodule update --init --recursive; }; f' Download the ledger code If you need them, here are the Git SSH key generation instructions. Clone the repository: cd [ working_directory ] git clone https://github.com/fetchai/ledger.git git checkout release/v0.6.x Update and initialise submodules from the repository root directory: cd ledger git pull git submodule update --init --recursive Make sure you have all the submodules: git submodule status If any submodules are missing, please check your installation. Build the ledger From the ledger directory, follow the steps to build the library: mkdir build cd build cmake .. make -j constellation You may have memory issues on make , so limit the number of cores (we chose 4): make -j 4 constellation If you want, you can build all the libraries: make -j 4 For the etch simulator, build the etch library: make etch","title":"Ubuntu"},{"location":"getting-started/installation-ubuntu/#building-the-fetchai-components","text":"Currently, the Fetch.AI Ledger and the open economic framework (OEF) are built and deployed invidually. This will change with the main net deployment towards the end of the year.","title":"Building the Fetch.AI components"},{"location":"getting-started/installation-ubuntu/#supported-platforms","text":"Ubuntu 18.04 (x86_64)","title":"Supported platforms"},{"location":"getting-started/installation-ubuntu/#initial-setup","text":"Set environment variables in /etc/profile : export CC = clang export CXX = clang++ Update: sudo apt-get update Install dependencies: apt-get install build-essential clang git cmake libssl-dev doxygen python3-dev python3-pip python3-venv Update: sudo apt-get update Add the git alias: git config --global alias.pullall '!f(){ git pull \"$@\" && git submodule sync --recursive && git submodule update --init --recursive; }; f'","title":"Initial setup"},{"location":"getting-started/installation-ubuntu/#download-the-ledger-code","text":"If you need them, here are the Git SSH key generation instructions. Clone the repository: cd [ working_directory ] git clone https://github.com/fetchai/ledger.git git checkout release/v0.6.x Update and initialise submodules from the repository root directory: cd ledger git pull git submodule update --init --recursive Make sure you have all the submodules: git submodule status If any submodules are missing, please check your installation.","title":"Download the ledger code"},{"location":"getting-started/installation-ubuntu/#build-the-ledger","text":"From the ledger directory, follow the steps to build the library: mkdir build cd build cmake .. make -j constellation You may have memory issues on make , so limit the number of cores (we chose 4): make -j 4 constellation If you want, you can build all the libraries: make -j 4 For the etch simulator, build the etch library: make etch","title":"Build the ledger"},{"location":"getting-started/oef-install/","text":"Initial setup First, get Docker . Next, pull our published image. docker pull fetchai/oef-search:latest Grab the configuration file. curl https://docs.fetch.ai/oef/assets/node_config.json \\ --output node_config.json And run the Docker image with the configuration. docker run -it -v ` pwd ` :/config -p 20000 :20000 -p 10000 :10000 -p 40000 :40000 -p 7500 fetchai/oef-search:latest node no_sh --config_file /config/node_config.json A successful run will start producing stats dumps after a few seconds. You'll need to have several ports available on your machine: 10000 , 20000 , 30000 , and 7500 . Get the OEF SDK First, run the pip installation command: pip3 install -v -v -v --no-cache-dir oef After that, let's check we installed the SDK correctly: python3 from oef import agents When a function needs a core address, use 127.0.0.1 and port 10000 . Get the example code Download the working examples bundle . Or curl them here: curl https://docs.fetch.ai/oef/assets/examples.tgz \\ --output examples.tgz","title":"Open Economic Framework"},{"location":"getting-started/oef-install/#initial-setup","text":"First, get Docker . Next, pull our published image. docker pull fetchai/oef-search:latest Grab the configuration file. curl https://docs.fetch.ai/oef/assets/node_config.json \\ --output node_config.json And run the Docker image with the configuration. docker run -it -v ` pwd ` :/config -p 20000 :20000 -p 10000 :10000 -p 40000 :40000 -p 7500 fetchai/oef-search:latest node no_sh --config_file /config/node_config.json A successful run will start producing stats dumps after a few seconds. You'll need to have several ports available on your machine: 10000 , 20000 , 30000 , and 7500 .","title":"Initial setup"},{"location":"getting-started/oef-install/#get-the-oef-sdk","text":"First, run the pip installation command: pip3 install -v -v -v --no-cache-dir oef After that, let's check we installed the SDK correctly: python3 from oef import agents When a function needs a core address, use 127.0.0.1 and port 10000 .","title":"Get the OEF SDK"},{"location":"getting-started/oef-install/#get-the-example-code","text":"Download the working examples bundle . Or curl them here: curl https://docs.fetch.ai/oef/assets/examples.tgz \\ --output examples.tgz","title":"Get the example code"},{"location":"getting-started/python-api-install/","text":"Build the Python libraries like this: pip3 install -U fetchai-ledger-api Or, download and install the Python library which interacts with a running ledger node. git clone git@github.com:fetchai/ledger-api-py.git -b release/v0.6.x Tip Make sure you are on the latest release branch in order to have the latest features. Install the library with the following command: cd ledger - api - py / python3 setup . py install Find out how to build a smart contract using the Python API here .","title":"Python Ledger API"},{"location":"getting-started/run-a-node/","text":"Run a local node From the build folder, navigate to the constellation app folder: cd apps/constellation Start a standalone test node: ./constellation -port 8100 -block-interval 3000 -standalone You should see output like this: F E \u2571 Constellation v0.4.1-rc1 T C Copyright 2018 -2019 ( c ) Fetch AI Ltd. H [ 2019 -06-03 16 :55:20.215, # 1 INFO : main ] Configuration: port......................: 8100 network mode..............: Standalone num executors.............: 1 num lanes.................: 1 num slices................: 500 bootstrap.................: 0 discoverable..............: 0 host name.................: external address..........: 127 .0.0.1 db-prefix.................: node_storage interface.................: 127 .0.0.1 mining....................: Yes tx processor threads......: 12 shard verification threads: 12 block interval............: 3000ms max peers.................: 3 peers update cycle........: 0ms peers.....................: manifest.......: - HTTP/0: tcp://127.0.0.1:8100 ( 8100 ) - CORE/0: tcp://127.0.0.1:8101 ( 8101 ) - Lane/0: tcp://127.0.0.1:8110 ( 8110 ) When you see the following message... [ 2019 -06-15 15 :24:39.383, # 1 INFO : P2PService ] CORE URI: tcp://127.0.0.1:8101 [ 2019 -06-15 15 :24:39.383, # 1 INFO : P2PService ] Num Initial Peers: 0 [ 2019 -06-15 15 :24:39.383, # 1 INFO : P2PService ] Starting P2PService... [ 2019 -06-15 15 :24:39.484, # 5 INFO : HTTPServer ] Starting HTTPServer on http://127.0.0.1:8100 [ 2019 -06-15 15 :24:39.524, # 6 WARN : NewVersionedRandomAccessStack ] Attempted to find if hash exists, but history is empty! [ 2019 -06-15 15 :24:39.524, # 6 WARN : NewVersionedRandomAccessStack ] Attempted to find if hash exists, but history is empty! [ 2019 -06-15 15 :24:39.525, # 7 INFO : BlockCoordinator ] Chain Sync complete on 0x780bbb1c050cd3d5c20fce89fa6f4e61c884315efeb44c54ceb956a50563683a (block: 0 prev: 0xd3efbefbefbefbefbefbefbefbe19e9deb22b3efbefbefbefbefbefbefbefbed) [ 2019 -06-15 15 :24:40.487, # 1 INFO : constellation ] Startup complete ...your node is running and you will be able to test smart contracts and autonomous agents. Navigate through to the OEF , etch language , or smart contracts links above and you will find instructions and tutorials.","title":"Run a local node"},{"location":"getting-started/versions/","text":"While we continue to work on developing separate applications for the Fetch.AI Ledger, Python Ledger API, and the Fetch.AI Open Economic Framework, it's important to make sure all running versions match up. For example: fetchai / ledger release / v0 .6 . x fetchai / ledger - api - py release / v0 .6 . x fetchai / oef - search - pluto master Against these, follow the documentation in line with the same versions. The documentation you are reading now is version: fetchai / docs release / v0 .6 . x","title":"Versions"},{"location":"ledger/architecture/","text":"Note We assume the reader is comfortable with high level concepts that underpin blockchain technology, such as public key cryptography, consensus, blockchain, and smart contracts. Sharding The Fetch.AI Ledger is unlike more traditional blockchain designs. Instead of a single chain of truth, the Fetch.AI Ledger is sharded into parallel lanes. This blockchain sharding design speeds up the network as contracts can execute concurrently and so provide a solution to the blockchain scalability problem. Furthermore, by sharding the world state in this way, transactions guarantee they only use certain resources, i.e. memory locations. This means that the size of a block can vary by increasing or decreasing the number of shards. This allows the network to balance block sizes against economic incentives, for example. The consequence of this design means the world state is best sharded across multiple machines to scale access and avoid resource locking. Constellation is the name of the main controlling node. The shards are termed lanes . The following diagram gives a high level overview of the components making up a constellation application. This is work in progress. High level architecture diagram Note For a more thorough understanding of the Fetch ledger architecture, please read the Fetch.AI whitepaper . Constellation Note This section is coming soon. Wallet API Note This section is coming soon. P2P Service Note This section is coming soon.","title":"Fetch Ledger architecture"},{"location":"ledger/architecture/#sharding","text":"The Fetch.AI Ledger is unlike more traditional blockchain designs. Instead of a single chain of truth, the Fetch.AI Ledger is sharded into parallel lanes. This blockchain sharding design speeds up the network as contracts can execute concurrently and so provide a solution to the blockchain scalability problem. Furthermore, by sharding the world state in this way, transactions guarantee they only use certain resources, i.e. memory locations. This means that the size of a block can vary by increasing or decreasing the number of shards. This allows the network to balance block sizes against economic incentives, for example. The consequence of this design means the world state is best sharded across multiple machines to scale access and avoid resource locking. Constellation is the name of the main controlling node. The shards are termed lanes . The following diagram gives a high level overview of the components making up a constellation application. This is work in progress.","title":"Sharding"},{"location":"ledger/architecture/#high-level-architecture-diagram","text":"Note For a more thorough understanding of the Fetch ledger architecture, please read the Fetch.AI whitepaper .","title":"High level architecture diagram"},{"location":"ledger/architecture/#constellation","text":"Note This section is coming soon.","title":"Constellation"},{"location":"ledger/architecture/#wallet-api","text":"Note This section is coming soon.","title":"Wallet API"},{"location":"ledger/architecture/#p2p-service","text":"Note This section is coming soon.","title":"P2P Service"},{"location":"ledger/fetch-token/","text":"In order to implement a static contract, create a new class that inherits from the Contract class and expose the relevant functions. In the following example, we will describe an implementation of the the Fetch token. First, we define the body of the contract as below: class TokenContract : public Contract { public : TokenContract (); ~ TokenContract () = default ; static constexpr char const * LOGGING_NAME = \"TokenContract\" ; private : // transaction handlers Status CreateWealth ( Transaction const & tx ); Status Transfer ( Transaction const & tx ); // queries Status Balance ( Query const & query , Query & response ); };","title":"Fetch token"},{"location":"ledger/fetch-workflow/","text":"","title":"Fetch workflow"},{"location":"ledger/maths-lib-overview/","text":"etch mathematics and machine learning operations are supported by a header-only fully-templated C++ library. Note Detailed developer documentation for the C++ implementation of the maths libraries will be available in the Fetch Ledger section in due course. Developers should be comfortable with SFINAE. Architecture A core component of the maths library is the tensor.hpp class which handles N-dimensional array mathematics. This is crucial for the machine learning library but can also be used for any generalised matrix algebra. The remainder of the library contains templated free functions that can be called with the following types: Built-in C++ types such as double , int , float , etc. C++ tensors of built-in types such as Tensor<double> . etch types such as Fixed32 . etch tensors types such as Tensor<Fixed32> . The header file fundamental_operators.hpp contains common operations Add , Subtract , Multiply , and Divide . The file matrix_operations.hpp contains Max , ArgMax , Product , Sum , Dot , etc. The standard_functions directory contains header files for additional standard operations. The following block diagram gives a rough indication of the library structure. Advice This is work in progress. Tensor A Tensor is a wrapper for a data_ object which is, by default, a SharedArray managed by the vectorise library. This library manages the vectorisation/SIMD on the underlying data. Tensor objects provide interfaces for manipulating arrays at a mathematical/algebraic level while allowing implementations to be efficient and vectorisable. Tensors have related helper classes such as TensorIterator , TensorBroadcast , and TensorSlice that permit efficient and convenient manipulation such as accessing, transposing, and slicing. In the next section we will look at the available mathematical functions in etch . Working with the maths library When working with the C++ maths library, take note of the following: Functions should have two interfaces: one that takes a reference to the return object, and one that creates the return object internally. Function design decisions should follow Numpy conventions where possible.","title":"Maths library introduction"},{"location":"ledger/maths-lib-overview/#architecture","text":"A core component of the maths library is the tensor.hpp class which handles N-dimensional array mathematics. This is crucial for the machine learning library but can also be used for any generalised matrix algebra. The remainder of the library contains templated free functions that can be called with the following types: Built-in C++ types such as double , int , float , etc. C++ tensors of built-in types such as Tensor<double> . etch types such as Fixed32 . etch tensors types such as Tensor<Fixed32> . The header file fundamental_operators.hpp contains common operations Add , Subtract , Multiply , and Divide . The file matrix_operations.hpp contains Max , ArgMax , Product , Sum , Dot , etc. The standard_functions directory contains header files for additional standard operations. The following block diagram gives a rough indication of the library structure. Advice This is work in progress.","title":"Architecture"},{"location":"ledger/maths-lib-overview/#tensor","text":"A Tensor is a wrapper for a data_ object which is, by default, a SharedArray managed by the vectorise library. This library manages the vectorisation/SIMD on the underlying data. Tensor objects provide interfaces for manipulating arrays at a mathematical/algebraic level while allowing implementations to be efficient and vectorisable. Tensors have related helper classes such as TensorIterator , TensorBroadcast , and TensorSlice that permit efficient and convenient manipulation such as accessing, transposing, and slicing. In the next section we will look at the available mathematical functions in etch .","title":"Tensor"},{"location":"ledger/maths-lib-overview/#working-with-the-maths-library","text":"When working with the C++ maths library, take note of the following: Functions should have two interfaces: one that takes a reference to the return object, and one that creates the return object internally. Function design decisions should follow Numpy conventions where possible.","title":"Working with the maths library"},{"location":"ledger/ml-introduction/","text":"The machine learning library is a generalised toolkit for building and running machine learning applications on Fetch Ledger nodes. Machine learning operations are implemented in etch . Like PyTorch and TensorFlow, we focus on neural networks and deep learning. In contrast, the library is compatible with etch FixedPoint data types and Tensors built with them. As etch FixedPoint data types implement integer mathematics, it is possible to compute precise results of complex mathematical operations - in line with deep neural networks requirements - on different architectures with guaranteed identical results . Since the IEEE 754 standard for floating-point arithmetic does not guarantee that the same program will deliver identical results on all conforming systems, and since the C++ standard does not enforce IEEE 754, the use of floats and doubles on different architectures is almost always going to result in tiny differences at extremely high levels of precision. For many applications this is no problem. However, the Fetch Ledger will be computing and storing the results of complex mathematical operations in smart contracts and these results will be cryptographically hashed. These hashes will need to be absolutely identical on every architecture attempting to verify them. This is not possible with existing machine learning frameworks. Architecture The following block diagram shows the inheritance structure for some of the key components of the ML library. Note This is work in progress. Graph Graph represents a computational graph made up of nodes. A Graph must be a directed acyclic graph (DAG). Therefore, when adding nodes, the inputs to the nodes must be specified and must never result in a cycle. Graph manages saving and loading existing graph states (a state dictionary) and checking for node name collisions. Nodes are positions in the graph which know from which other nodes to draw inputs. They are able to perform forward and backward computation according to a particular operation, or Op . Each node is associated with a particular Op and this defines the specifics of what happens whenever the forward or backward methods are called. Often the forward method calls upon an existing maths function from the math library; for example the addition Op called on the math library implementation of Add . The backward method computes the gradient associated with the forward operation given a particular error signal. Ops To inject data into the computational Graph , special Ops are required that can have data assigned to them. These are placeholders. Weights are a specialisation of placeholders in that the data assigned to them is randomly initialised and their data is trainable via back-propagation. Finally there may be further specialisations of weights, such as embeddings, that offer additional functionality with respect to accessing and updating the data. Layers Layers , which inherit from SubGraphs , are wrappers around multiple Ops that are commonly repeated. For example, a fully connected layer which wraps the dot product between the weights and the input tensor, followed by the addition of the bias tensor, and possibly also followed by an activation function. DataLoaders DataLoaders manage input training data when training the weights in the neural network. They are responsible for parsing data into a format compatible with the rest of the machine learning library and then sampling the data for training and testing. A specific DataLoader is often needed for each machine learning problem, as input data formats will tend to vary. However, the DataLoader abstract class mandates the necessary methods for all DataLoaders . Notes for working with the C++ machine learning library Every Op must have a DESCRIPTOR . This generates a unique node name when name collisions are detected in a graph. It is also used for logging/error reporting. Node names are not guaranteed to be identical to the input string specified by the developer on AddNode . This is because the graph automatically resolves name collisions such that every node is uniquely named. The function ComputeOutputShape for classes that inherit from Ops is expensive and should only be used for initialisation or in ASSERT . On Forward you can use output.shape() instead and for Backward there is error_signal.shape() . Batch dimension is always trailing dimension. If you work with a single data point, it needs to have trailing dimension of size 1. DataLoaders are designed to return a pair of {Label,{Data}} where Data are in vector. In the next section, we will detail all the machine learning functions available in etch and provide runnable examples.","title":"Machine learning introduction"},{"location":"ledger/ml-introduction/#architecture","text":"The following block diagram shows the inheritance structure for some of the key components of the ML library. Note This is work in progress.","title":"Architecture"},{"location":"ledger/ml-introduction/#graph","text":"Graph represents a computational graph made up of nodes. A Graph must be a directed acyclic graph (DAG). Therefore, when adding nodes, the inputs to the nodes must be specified and must never result in a cycle. Graph manages saving and loading existing graph states (a state dictionary) and checking for node name collisions. Nodes are positions in the graph which know from which other nodes to draw inputs. They are able to perform forward and backward computation according to a particular operation, or Op . Each node is associated with a particular Op and this defines the specifics of what happens whenever the forward or backward methods are called. Often the forward method calls upon an existing maths function from the math library; for example the addition Op called on the math library implementation of Add . The backward method computes the gradient associated with the forward operation given a particular error signal.","title":"Graph"},{"location":"ledger/ml-introduction/#ops","text":"To inject data into the computational Graph , special Ops are required that can have data assigned to them. These are placeholders. Weights are a specialisation of placeholders in that the data assigned to them is randomly initialised and their data is trainable via back-propagation. Finally there may be further specialisations of weights, such as embeddings, that offer additional functionality with respect to accessing and updating the data.","title":"Ops"},{"location":"ledger/ml-introduction/#layers","text":"Layers , which inherit from SubGraphs , are wrappers around multiple Ops that are commonly repeated. For example, a fully connected layer which wraps the dot product between the weights and the input tensor, followed by the addition of the bias tensor, and possibly also followed by an activation function.","title":"Layers"},{"location":"ledger/ml-introduction/#dataloaders","text":"DataLoaders manage input training data when training the weights in the neural network. They are responsible for parsing data into a format compatible with the rest of the machine learning library and then sampling the data for training and testing. A specific DataLoader is often needed for each machine learning problem, as input data formats will tend to vary. However, the DataLoader abstract class mandates the necessary methods for all DataLoaders .","title":"DataLoaders"},{"location":"ledger/ml-introduction/#notes-for-working-with-the-c-machine-learning-library","text":"Every Op must have a DESCRIPTOR . This generates a unique node name when name collisions are detected in a graph. It is also used for logging/error reporting. Node names are not guaranteed to be identical to the input string specified by the developer on AddNode . This is because the graph automatically resolves name collisions such that every node is uniquely named. The function ComputeOutputShape for classes that inherit from Ops is expensive and should only be used for initialisation or in ASSERT . On Forward you can use output.shape() instead and for Backward there is error_signal.shape() . Batch dimension is always trailing dimension. If you work with a single data point, it needs to have trailing dimension of size 1. DataLoaders are designed to return a pair of {Label,{Data}} where Data are in vector. In the next section, we will detail all the machine learning functions available in etch and provide runnable examples.","title":"Notes for working with the C++ machine learning library"},{"location":"ledger/static-dynamic/","text":"Static contracts A static contract is business logic built at the time the ledger is compiled. The code is unchangeable in the sense that the only way to update the code or deploy new static contracts is to recompile the ledger and distribute new executables to all participants. Note We will demo a Fetch token static contract shortly. Dynamic contracts A smart contract is the second type of business logic found on Fetch ledger nodes. Smart contracts can be deployed at runtime. Find out about Fetch smart contracts in the Smart Contract section here .","title":"Static and dynamic contracts"},{"location":"ledger/static-dynamic/#static-contracts","text":"A static contract is business logic built at the time the ledger is compiled. The code is unchangeable in the sense that the only way to update the code or deploy new static contracts is to recompile the ledger and distribute new executables to all participants. Note We will demo a Fetch token static contract shortly.","title":"Static contracts"},{"location":"ledger/static-dynamic/#dynamic-contracts","text":"A smart contract is the second type of business logic found on Fetch ledger nodes. Smart contracts can be deployed at runtime. Find out about Fetch smart contracts in the Smart Contract section here .","title":"Dynamic contracts"},{"location":"ledger/style-guide/","text":"Summary Use STL types wherever possible. Always check error codes and return codes. Do not rely on exceptions to avoid taking responsibility. Do not assume, do assert. Write tests and run them. If a value is const , declare it so. Comment the non-obvious, not the obvious. Provide API documentation with your code. Prefer shared_ptr and unique_ptr over raw pointers. Use references where the value cannot be null. Use pointers where it can. Always prefer passing by const reference or reference where possible. Use make_shared and make_unique for shared pointers. Don't use #define . If you ignore this guidance, choose a FETCH_STARTING_REALLY_LONG_NAME_THAT_CANNOT_POSSIBLY_CLASH_WITH_ANYTHING_ELSE and undefine it as soon as you are done with it. Use static_cast , reinterpret_cast , dynamic_cast , etc., rather than C-style casts. Lines should be no longer than 100 characters. Use spaces, not tabs. Curly brackets {...} should be on their own line. There should be a space after conditionals, i.e. if (test) Use meaningful names. Use C++14 features, not C++17. Structs are for POD. Classes are for everything else. initialise class members in the following order of preference: Inline initialisation. Constructor initialiser list. Constructor body. Uninitialised memory can cause serious bugs. Use nullptr , not 0 or NULL . Include header definitions in the same file. Use #pragma once in headers. Order of includes: Related header. C library. C++ library. Other libraries. Fetch library. Do not do using namespace foo or namespace baz = ::foo::bar::baz in .hpp files. Stick to RAII principle and automatic memory management - destructors are ideally empty. Do not throw exceptions in destructors as this can crash the program. Use exceptions only for exceptional circumstances. Handle normal errors gracefully. Use the following keywords when appropriate: explicit . override . virtual . final . noexcept . Declare all constructors and assignment operators concretely or with default or delete (prefer delete). Avoid auto except when the return type is clear. Avoid use of RTTI. Pre increment: ++i as it is more performant for non primitive types. Prefer (u)int(16/32/64)_t and std::size_t . Use int const &i over const int &i . Lambda captures must be explicit ref or copy. using is preferable to typedef . Make using private unless you intend to expose it. Classes in this order: public . protected . private . Use SQL style initialiser for lists and inheritance lists. snake_case_ variables with trailing underscore, except in structs where it is snake_case without underscore. Enums use UPPER_CASE . Macros use UPPER_CASE . Include a comment summary at the top of all files. Split class definition across a header and source file by default. Header files: .hpp . Source files: .cpp . TODOs should refer to the author in the style TODO( HUT ) : . Avoid leaving TODOs in code. No spaces inside (parenthesis) or <template> unless it improves readability. No spaces around arrow: this->fnc(); . No trailing whitespace. Align attributes by group in classes, and initialisers. namespace {.<template T> only allowed if typedef / using indicates the type. Use templates judiciously and defined to library code where only a small number of devs need understand them. Variables should be initialised with = if primitive, or braced initialisation with parentheses if required. initialiser lists should be initialised with parentheses by default, otherwise braced initialisation. Formatting Use spaces, not tabs. Indent. Make use of the apply_style script provided for formatting. Naming Use meaningful names. For structs, use all lowercase with underscore to separate words, or camel case, i.e. first_name and firstName are both valid. For classes, private member variables end with an _ . For templates, use all uppercase with underscores to separate words. Long and explicit names are preferred to short and obscure names, e.g. template <typename ARRAY_TYPE> is preferable to template <typename A>); . Short names are acceptable where the type is obvious and reused many times in complex equations. Comments and documentation Don't do the following: // Computes exponential using magic double Exp ( double const & x ) { // No idea where these magic constants come from static double const a = double ( 1ull << 20 ) / M_LN2 ; static double const b = (( 1ull << ( 10 )) - 1 ) * double ( 1ull << 20 ); - 60801 ; double in = x * a + b ; union { // How the f$#k does this work? double d ; uint32_t i [ 2 ]; } conv ; conv . i [ 1 ] = static_cast < uint32_t > ( in ); conv . i [ 0 ] = 0 ; return conv . d ; } Instead, do the following: /* Approximation of the exponential function. * @x is the argument that is used in the exponent 2^(x / M_LN2). * * We exploit the IEEE-754 standard to efficiently create a linear * interpolation between points of the form 2^n where n is an integer. * * You can find the full details in * [1] \"A fast, compact approximation of the exponential function\", * Nicol N. Schraudolph, 1999 Neural computation 11, 853-862. * * @return the exponential of x. */ double Exp ( double const & x ) { // We use the constants explained in [1] and additional make e the // base rather than using 2. static double const a = double ( 1ull << 20 ) / M_LN2 ; static double const b = (( 1ull << ( 10 )) - 1 ) * double ( 1ull << 20 ); - 60801 ; double in = x * a + b ; // Move the computed bits into the exponent with spilling into the // Mantissa. The spilling creates the linear interpolation, while // the exponent creates exact results whenever the argument is an integer. union { double d ; uint32_t i [ 2 ]; } conv ; conv . i [ 1 ] = static_cast < uint32_t > ( in ); conv . i [ 0 ] = 0 ; return conv . d ; } If you do not understand some code, contact the original author. If he or she has left the company ask the most competent person. After working out what a piece of a non-obvious code is doing, remember to document it. Finally, comment the non-obvious: // Turns out sorting this list before processing it is faster due to branch // prediction, so don't remove this without checking the profile: std :: sort ( users . begin (), users . end (), UserSortPredicate ()); for ( const User & user : users ) { if ( true == user . ready ) { // Do something... } // if (user ready) } // iterate (users) Use C++14 We use C++14, but currently consider C++17 too immature for usage. Namespaces Don't do the following: namespace fetch { using namespace std ; // Pollutes all of the fetch namespace and causes // problems for every one. class MyFetchClass { public : void Greet () { cout << \"Hello\" << endl ; } // ... }; }; Instead, do the following: namespace fetch { namespace details { struct FecthImpl { /* ... */ }; void HelperFunction ( FecthImpl & s ) { /* ... */ } }; class MyFetchClass { public : void DoSomeThing () { // This improves readability using namespace details ; FetchImpl f ; HelperFunction ( f ); } // ... }; }; Structs Use structs for passive data and, in some cases, template meta programming. Use classes for everything else. For example: struct Person { std :: string name ; int age ; // ... }; Classes Mark all constructors and assignment operators explicitly; even those which are implicit. For example: class Transaction { public : Transaction () = default ; Transaction ( Transaction const & ) = default ; Transaction ( Transaction && ) = deleted ; ~ Transaction () = default ; Transaction operator ( Transaction const & ) = default ; Transaction operator ( Transaction && ) = deleted ; } This ensures there is no confusion about the intended behaviour of the class. Likewise, mark unneeded default implementations as deleted. C++ infers whether to create implicit constructors based on whether there are user defined ones. This means that when someone declares a constructor, C++ may remove the default constructor. Mark a class final if it is not meant to be subclassed. The same counts for final implementations of virtual functions. For example: class Foo { public : virtual ~ Foo () { } virtual void Greet () = 0 ; virtual void Say ( std :: string const & ) = 0 ; }; class Bar : public Foo { public : void Greet () override final { // ... } void Say ( std :: string const & what ) override { // .. }; }; class Baz final : public Bar { public : void Say ( std :: string const & what ) override { // ... } }; C++14 allows for inline initialisation of member variables which should be preferred at all times as uninitialised memory can have secondary effects making it almost impossible to debug a problem. When it is not possible to use inline initialisation, member variables should be initialised using the constructor initialisation list where they must be listed in the order they appear. Last resort is initialisation inside the constructors body. In most cases, a combination of the above will be used. For example: class MyClass { public : MyClass () = default ; MyClass ( std :: size_t n ) : size_ ( n ) { pointer_ = new int [ n ]; for ( std :: size_t i = 0 ; i < n ; ++ i ) { pointer_ [ i ] = 0 ; } } // ... private : std :: size_t size_ = 0 ; int * pointer_ = nullptr ; }; Here, inline initialisation ensures that the default constructor does not produce uninitialised memory. In the second constructor, we manually initialise the pointer_ but size_ can be set using the initialisation list. nullptr Use the new C++11 nullptr keyword which designates an rvalue constant serving as a universal null pointer literal. This replaces the buggy and weakly-typed literal 0 and the infamous NULL macro. nullptr is also type safe. Resource handling It is important to manage resources whose lifecycle needs strict control, such as: Thread synchronisation constructs (e.g. mutex). Memory. Filesystem objects. Network connections. Database sessions. Etc. This is especially critical in environments where exceptions can occur. Use a scope based smart pointer concept to manage resource lifecycle. The Smart Pointer concept exploits the C++ native constructor-destructor (unbreakable) bond for the class/struct instance created on the stack using direct initialisation where its lifecycle is strictly controlled by the encapsulating scope inside of the created instance. The most important aspect of this strong bond is that the destructor is automatically called when the code flow is exiting the encapsulating scope. This includes exits caused by an exception being thrown. Below are a few examples of how resources should be managed in the code: Exception enabled environment and its impact on resource handling The most important rule is that the destructor will NEVER throw an exception in any circumstance. The reason for this is that a destructor for a directly initialised object (the lifecycle of which is controlled by a scope) is called automatically when any exception is thrown within that scope. This means that if the destructor throws yet another exception, it forces the C++ runtime to call std::terminate of the process (as per the C++ standard definition), since the C++ runtime is already in the stack unwinding process caused by the first exception. See more about this scenario at cppreference.com and at codingstandard.com . Handling THREAD synchronisation resources Use locking guards provided in C++ std namespace, such as: std::unique_lock<...> . std::lock_guard<...> . The Fetch Ledger codebase offers a couple implementations of mutex in the fetch::mutex namespace which conform to a std locking API contract. They can be used with the above-mentioned locking guard constructs from std namespace. Please prefer them in favour of plain std::mutex : fetch::mutex::DebugMutex fetch::mutex::ProductionMutex The std::unique_lock<...> The std::unique_lock is a superset of the std::lock_guard in terms of the API and its capabilities. It offers more flexibility and allows the following: The constructor of the class can take a lockable object (e.g. mutex) in any state (locked or unlocked), and thus adopting its pre-existing lock state. It can lock & unlock lockable objects when desired (as many times as necessary). It can release control of the lockable object it controls. Its destructor unlocks the lockable object if it is in locked state. #include <condition_variable> #include <mutex> #include <thread> //* A condition used in cooperation with `unique_lock<...>` //* to retain state across lock and signal change of the state std :: condition_variable condition ; //* Variable keeping the state bool a_state = 0 ; //* Global mutex variable std :: mutex ( mtx ); auto increment_fnc () -> void { { //* this constructor locks mutex automatically std :: unique_lock < mutex > lock ( mtx ); //* Updating value of state keeping variable (in thread safe way - see comment bellow) ++ a_state ; //* It is *not* necessary to explicitly call `lock.unlock()` since //* it will be called implicitly by destructor of the `lock` object. } //* Signal on condition to notify *ALL* listeners waiting for the signal. //* Mind to note here that this is **independent** from specific //* synchronisation object (like mutex), reason being it can be signalled //* from anywhere (e.g. outside of mutex locked scope). condition . notify_all (); } auto decrement_fnc () -> void { std :: unique_lock < mutex > lock ( mtx ); //* Waiting for condition to signal. //* An std::function (e.g. lambda) can be passed to prevent spurious //* wake ups, for example condition.wait(lock, [](){/* ... */ return A_CONDITION;}) //* The `wait(lock)` implicitly UNlock the mutex **BEFORE** falling //* to wait state (essentially relocating thread to wait queue on OS level). condition . wait ( lock , [ orig_state = a_state , & state = a_state ](){ //* Here we are trying to figure whether the state has changed since we started //* to monitor/listen to the signalling. if ( orig_state < state ) { -- state ; //* Modifying state return true ; } return false ; }); //* The `wait(lock)` implicitly reacquire back (locks) the mutex after it handled //* signalled condition. //* It is *not* necessary to explicitly call `lock.unlock()` since //* it will be called implicitly by destructor of the `lock` object. } int main ( int argc , char * argv []) { std :: thread t1 ([]() { increment_fnc (); }); std :: thread t2 ([]() { decrement_fnc (); }); t1 . join (); t2 . join (); } The std::lock_guard<...> The std::lock_guard<T> offers the most trivial API possible - constructor and destructor. It locks the synchronisation object of T type immediately at construction time, and releases the lock in the destructor. The constructor of this class is able to take a lockable object (e.g. mutex) in any state (locked or unlocked) and thus adopting its pre-existing lock state. For example: #include <mutex> std :: mutex ( mtx ); { std :: unique_lock < mutex > guard ( mtx ); //* Some code desired to be executed thread safe manner. //* Automatically called destructor of the `guard` instance //* will implicitly unlock the mutex. } Handling dynamically allocated MEMORY resources Use smart pointers from the std:: namespace dedicated to memory management, such as the most frequently used: std::shared_ptr<...> . std::unique_ptr<...> . Please note, the default delete policy for these types uses the default C++ delete operator for single objects. However, the API of these types offers custom deleter and allocator functions for managing non-default allocation/deallocation policies such as needed when managing array object types. Below are some types which guarantee to manage array object types (continuous block of memory) by default, and other types which do memory management as a side effect of their primary business logic. std::vector<...> guarantees to manage a continuous block of memory (array) by definition. std::string<...> guarantees to manage a continuous block of memory (array) by definition. SharedArray<...> and Array<...> classes (from fetch::memory namespace) that guarantee to manage a continuous block of memory (array) by definition. Classes from fetch::byte_array namespac, such as BasicByteArray Transfer between ownership models It is safe to transfer ownership from std::unique_ptr to std::shared_ptr . However, do NOT transfer ownership the other way around, i.e. from std::shared_ptr to std::unique_ptr . Any justification for doing this is highly questionable. If you really feel it is necessary to do this, then keep the following in mind: It is a non -trivial operation. The shared_ptr type is NOT designed for this. If you still want to proceed, then read this which may provide some guidance. Example of using smart pointer with shared ownership: #include <memory> #include <iostream> //* Parent Scope block { std :: shared_ptr < int > a0 ; //* Nested scope block { std :: shared_ptr < int > a1 = std :: make_shared < int > ( 5 ); //* refcount=1 a0 = a1 ; //* The `a1` instance become shared at this point (refcount=2) //* BOTH instances are valid, controlling the same `int` instance: std :: cout << \"a0 = \" << * a0 << \", a1 = \" << * a1 << std :: endl ; throw std :: exception (); //* The exception will cause stack unwinding, during which //* is the destructor of `a1` instance called automatically, //* what decrements refcount of shared object (to 1). //* At this point, the `a0` shared object is controlling lifecycle //* of the `int` instance created above in this scope. } //* We are still in stack unwinding process here (due to earlier exception), //* during which automatically called destructor of `a0` instance decrements //* refcount of shared object (to 0), what finally results to destruction of //* the `int` instance allocated & initialised in the nested scope above. } Example of using smart pointer with exclusive ownership: #include <memory> //* Parent Scope block { std :: unique_ptr < int > a0 ; //* Nested scope block { std :: unique_ptr < int > a1 = std :: make_unique < int > ( 5 ); a0 = a1 ; //* Transfer of OWNERSHIP from `a1` to `a0` //* The `a1` does NOT control lifecycle of the `int` instance anymore. //* This WILL result to throwing an exception since `a1` instance //* is initialised to `nullptr`: std :: cout << \"a1=\" << * a1 << std :: endl ; //* Automatically called destructor of `a1` instance, //* which does NOTHING since `a1` does NOT possess //* control over any object. } //* At this point, The `a0` variable is still controlling life-cycle of the //* `int` instance created in nested scope above. //* Automatically called destructor of `a0` instance will //* result to destruction of the `int` instance allocated & initialised //* in the nested scope above. }","title":"Fetch Ledger style guide"},{"location":"ledger/style-guide/#summary","text":"Use STL types wherever possible. Always check error codes and return codes. Do not rely on exceptions to avoid taking responsibility. Do not assume, do assert. Write tests and run them. If a value is const , declare it so. Comment the non-obvious, not the obvious. Provide API documentation with your code. Prefer shared_ptr and unique_ptr over raw pointers. Use references where the value cannot be null. Use pointers where it can. Always prefer passing by const reference or reference where possible. Use make_shared and make_unique for shared pointers. Don't use #define . If you ignore this guidance, choose a FETCH_STARTING_REALLY_LONG_NAME_THAT_CANNOT_POSSIBLY_CLASH_WITH_ANYTHING_ELSE and undefine it as soon as you are done with it. Use static_cast , reinterpret_cast , dynamic_cast , etc., rather than C-style casts. Lines should be no longer than 100 characters. Use spaces, not tabs. Curly brackets {...} should be on their own line. There should be a space after conditionals, i.e. if (test) Use meaningful names. Use C++14 features, not C++17. Structs are for POD. Classes are for everything else. initialise class members in the following order of preference: Inline initialisation. Constructor initialiser list. Constructor body. Uninitialised memory can cause serious bugs. Use nullptr , not 0 or NULL . Include header definitions in the same file. Use #pragma once in headers. Order of includes: Related header. C library. C++ library. Other libraries. Fetch library. Do not do using namespace foo or namespace baz = ::foo::bar::baz in .hpp files. Stick to RAII principle and automatic memory management - destructors are ideally empty. Do not throw exceptions in destructors as this can crash the program. Use exceptions only for exceptional circumstances. Handle normal errors gracefully. Use the following keywords when appropriate: explicit . override . virtual . final . noexcept . Declare all constructors and assignment operators concretely or with default or delete (prefer delete). Avoid auto except when the return type is clear. Avoid use of RTTI. Pre increment: ++i as it is more performant for non primitive types. Prefer (u)int(16/32/64)_t and std::size_t . Use int const &i over const int &i . Lambda captures must be explicit ref or copy. using is preferable to typedef . Make using private unless you intend to expose it. Classes in this order: public . protected . private . Use SQL style initialiser for lists and inheritance lists. snake_case_ variables with trailing underscore, except in structs where it is snake_case without underscore. Enums use UPPER_CASE . Macros use UPPER_CASE . Include a comment summary at the top of all files. Split class definition across a header and source file by default. Header files: .hpp . Source files: .cpp . TODOs should refer to the author in the style TODO( HUT ) : . Avoid leaving TODOs in code. No spaces inside (parenthesis) or <template> unless it improves readability. No spaces around arrow: this->fnc(); . No trailing whitespace. Align attributes by group in classes, and initialisers. namespace {.<template T> only allowed if typedef / using indicates the type. Use templates judiciously and defined to library code where only a small number of devs need understand them. Variables should be initialised with = if primitive, or braced initialisation with parentheses if required. initialiser lists should be initialised with parentheses by default, otherwise braced initialisation.","title":"Summary"},{"location":"ledger/style-guide/#formatting","text":"Use spaces, not tabs. Indent. Make use of the apply_style script provided for formatting.","title":"Formatting"},{"location":"ledger/style-guide/#naming","text":"Use meaningful names. For structs, use all lowercase with underscore to separate words, or camel case, i.e. first_name and firstName are both valid. For classes, private member variables end with an _ . For templates, use all uppercase with underscores to separate words. Long and explicit names are preferred to short and obscure names, e.g. template <typename ARRAY_TYPE> is preferable to template <typename A>); . Short names are acceptable where the type is obvious and reused many times in complex equations.","title":"Naming"},{"location":"ledger/style-guide/#comments-and-documentation","text":"Don't do the following: // Computes exponential using magic double Exp ( double const & x ) { // No idea where these magic constants come from static double const a = double ( 1ull << 20 ) / M_LN2 ; static double const b = (( 1ull << ( 10 )) - 1 ) * double ( 1ull << 20 ); - 60801 ; double in = x * a + b ; union { // How the f$#k does this work? double d ; uint32_t i [ 2 ]; } conv ; conv . i [ 1 ] = static_cast < uint32_t > ( in ); conv . i [ 0 ] = 0 ; return conv . d ; } Instead, do the following: /* Approximation of the exponential function. * @x is the argument that is used in the exponent 2^(x / M_LN2). * * We exploit the IEEE-754 standard to efficiently create a linear * interpolation between points of the form 2^n where n is an integer. * * You can find the full details in * [1] \"A fast, compact approximation of the exponential function\", * Nicol N. Schraudolph, 1999 Neural computation 11, 853-862. * * @return the exponential of x. */ double Exp ( double const & x ) { // We use the constants explained in [1] and additional make e the // base rather than using 2. static double const a = double ( 1ull << 20 ) / M_LN2 ; static double const b = (( 1ull << ( 10 )) - 1 ) * double ( 1ull << 20 ); - 60801 ; double in = x * a + b ; // Move the computed bits into the exponent with spilling into the // Mantissa. The spilling creates the linear interpolation, while // the exponent creates exact results whenever the argument is an integer. union { double d ; uint32_t i [ 2 ]; } conv ; conv . i [ 1 ] = static_cast < uint32_t > ( in ); conv . i [ 0 ] = 0 ; return conv . d ; } If you do not understand some code, contact the original author. If he or she has left the company ask the most competent person. After working out what a piece of a non-obvious code is doing, remember to document it. Finally, comment the non-obvious: // Turns out sorting this list before processing it is faster due to branch // prediction, so don't remove this without checking the profile: std :: sort ( users . begin (), users . end (), UserSortPredicate ()); for ( const User & user : users ) { if ( true == user . ready ) { // Do something... } // if (user ready) } // iterate (users)","title":"Comments and documentation"},{"location":"ledger/style-guide/#use-c14","text":"We use C++14, but currently consider C++17 too immature for usage.","title":"Use C++14"},{"location":"ledger/style-guide/#namespaces","text":"Don't do the following: namespace fetch { using namespace std ; // Pollutes all of the fetch namespace and causes // problems for every one. class MyFetchClass { public : void Greet () { cout << \"Hello\" << endl ; } // ... }; }; Instead, do the following: namespace fetch { namespace details { struct FecthImpl { /* ... */ }; void HelperFunction ( FecthImpl & s ) { /* ... */ } }; class MyFetchClass { public : void DoSomeThing () { // This improves readability using namespace details ; FetchImpl f ; HelperFunction ( f ); } // ... }; };","title":"Namespaces"},{"location":"ledger/style-guide/#structs","text":"Use structs for passive data and, in some cases, template meta programming. Use classes for everything else. For example: struct Person { std :: string name ; int age ; // ... };","title":"Structs"},{"location":"ledger/style-guide/#classes","text":"Mark all constructors and assignment operators explicitly; even those which are implicit. For example: class Transaction { public : Transaction () = default ; Transaction ( Transaction const & ) = default ; Transaction ( Transaction && ) = deleted ; ~ Transaction () = default ; Transaction operator ( Transaction const & ) = default ; Transaction operator ( Transaction && ) = deleted ; } This ensures there is no confusion about the intended behaviour of the class. Likewise, mark unneeded default implementations as deleted. C++ infers whether to create implicit constructors based on whether there are user defined ones. This means that when someone declares a constructor, C++ may remove the default constructor. Mark a class final if it is not meant to be subclassed. The same counts for final implementations of virtual functions. For example: class Foo { public : virtual ~ Foo () { } virtual void Greet () = 0 ; virtual void Say ( std :: string const & ) = 0 ; }; class Bar : public Foo { public : void Greet () override final { // ... } void Say ( std :: string const & what ) override { // .. }; }; class Baz final : public Bar { public : void Say ( std :: string const & what ) override { // ... } }; C++14 allows for inline initialisation of member variables which should be preferred at all times as uninitialised memory can have secondary effects making it almost impossible to debug a problem. When it is not possible to use inline initialisation, member variables should be initialised using the constructor initialisation list where they must be listed in the order they appear. Last resort is initialisation inside the constructors body. In most cases, a combination of the above will be used. For example: class MyClass { public : MyClass () = default ; MyClass ( std :: size_t n ) : size_ ( n ) { pointer_ = new int [ n ]; for ( std :: size_t i = 0 ; i < n ; ++ i ) { pointer_ [ i ] = 0 ; } } // ... private : std :: size_t size_ = 0 ; int * pointer_ = nullptr ; }; Here, inline initialisation ensures that the default constructor does not produce uninitialised memory. In the second constructor, we manually initialise the pointer_ but size_ can be set using the initialisation list.","title":"Classes"},{"location":"ledger/style-guide/#nullptr","text":"Use the new C++11 nullptr keyword which designates an rvalue constant serving as a universal null pointer literal. This replaces the buggy and weakly-typed literal 0 and the infamous NULL macro. nullptr is also type safe.","title":"nullptr"},{"location":"ledger/style-guide/#resource-handling","text":"It is important to manage resources whose lifecycle needs strict control, such as: Thread synchronisation constructs (e.g. mutex). Memory. Filesystem objects. Network connections. Database sessions. Etc. This is especially critical in environments where exceptions can occur. Use a scope based smart pointer concept to manage resource lifecycle. The Smart Pointer concept exploits the C++ native constructor-destructor (unbreakable) bond for the class/struct instance created on the stack using direct initialisation where its lifecycle is strictly controlled by the encapsulating scope inside of the created instance. The most important aspect of this strong bond is that the destructor is automatically called when the code flow is exiting the encapsulating scope. This includes exits caused by an exception being thrown. Below are a few examples of how resources should be managed in the code:","title":"Resource handling"},{"location":"ledger/style-guide/#exception-enabled-environment-and-its-impact-on-resource-handling","text":"The most important rule is that the destructor will NEVER throw an exception in any circumstance. The reason for this is that a destructor for a directly initialised object (the lifecycle of which is controlled by a scope) is called automatically when any exception is thrown within that scope. This means that if the destructor throws yet another exception, it forces the C++ runtime to call std::terminate of the process (as per the C++ standard definition), since the C++ runtime is already in the stack unwinding process caused by the first exception. See more about this scenario at cppreference.com and at codingstandard.com .","title":"Exception enabled environment and its impact on resource handling"},{"location":"ledger/style-guide/#handling-thread-synchronisation-resources","text":"Use locking guards provided in C++ std namespace, such as: std::unique_lock<...> . std::lock_guard<...> . The Fetch Ledger codebase offers a couple implementations of mutex in the fetch::mutex namespace which conform to a std locking API contract. They can be used with the above-mentioned locking guard constructs from std namespace. Please prefer them in favour of plain std::mutex : fetch::mutex::DebugMutex fetch::mutex::ProductionMutex","title":"Handling THREAD synchronisation resources"},{"location":"ledger/style-guide/#the-stdunique_lockltgt","text":"The std::unique_lock is a superset of the std::lock_guard in terms of the API and its capabilities. It offers more flexibility and allows the following: The constructor of the class can take a lockable object (e.g. mutex) in any state (locked or unlocked), and thus adopting its pre-existing lock state. It can lock & unlock lockable objects when desired (as many times as necessary). It can release control of the lockable object it controls. Its destructor unlocks the lockable object if it is in locked state. #include <condition_variable> #include <mutex> #include <thread> //* A condition used in cooperation with `unique_lock<...>` //* to retain state across lock and signal change of the state std :: condition_variable condition ; //* Variable keeping the state bool a_state = 0 ; //* Global mutex variable std :: mutex ( mtx ); auto increment_fnc () -> void { { //* this constructor locks mutex automatically std :: unique_lock < mutex > lock ( mtx ); //* Updating value of state keeping variable (in thread safe way - see comment bellow) ++ a_state ; //* It is *not* necessary to explicitly call `lock.unlock()` since //* it will be called implicitly by destructor of the `lock` object. } //* Signal on condition to notify *ALL* listeners waiting for the signal. //* Mind to note here that this is **independent** from specific //* synchronisation object (like mutex), reason being it can be signalled //* from anywhere (e.g. outside of mutex locked scope). condition . notify_all (); } auto decrement_fnc () -> void { std :: unique_lock < mutex > lock ( mtx ); //* Waiting for condition to signal. //* An std::function (e.g. lambda) can be passed to prevent spurious //* wake ups, for example condition.wait(lock, [](){/* ... */ return A_CONDITION;}) //* The `wait(lock)` implicitly UNlock the mutex **BEFORE** falling //* to wait state (essentially relocating thread to wait queue on OS level). condition . wait ( lock , [ orig_state = a_state , & state = a_state ](){ //* Here we are trying to figure whether the state has changed since we started //* to monitor/listen to the signalling. if ( orig_state < state ) { -- state ; //* Modifying state return true ; } return false ; }); //* The `wait(lock)` implicitly reacquire back (locks) the mutex after it handled //* signalled condition. //* It is *not* necessary to explicitly call `lock.unlock()` since //* it will be called implicitly by destructor of the `lock` object. } int main ( int argc , char * argv []) { std :: thread t1 ([]() { increment_fnc (); }); std :: thread t2 ([]() { decrement_fnc (); }); t1 . join (); t2 . join (); }","title":"The std::unique_lock&lt;...&gt;"},{"location":"ledger/style-guide/#the-stdlock_guardltgt","text":"The std::lock_guard<T> offers the most trivial API possible - constructor and destructor. It locks the synchronisation object of T type immediately at construction time, and releases the lock in the destructor. The constructor of this class is able to take a lockable object (e.g. mutex) in any state (locked or unlocked) and thus adopting its pre-existing lock state. For example: #include <mutex> std :: mutex ( mtx ); { std :: unique_lock < mutex > guard ( mtx ); //* Some code desired to be executed thread safe manner. //* Automatically called destructor of the `guard` instance //* will implicitly unlock the mutex. }","title":"The std::lock_guard&lt;...&gt;"},{"location":"ledger/style-guide/#handling-dynamically-allocated-memory-resources","text":"Use smart pointers from the std:: namespace dedicated to memory management, such as the most frequently used: std::shared_ptr<...> . std::unique_ptr<...> . Please note, the default delete policy for these types uses the default C++ delete operator for single objects. However, the API of these types offers custom deleter and allocator functions for managing non-default allocation/deallocation policies such as needed when managing array object types. Below are some types which guarantee to manage array object types (continuous block of memory) by default, and other types which do memory management as a side effect of their primary business logic. std::vector<...> guarantees to manage a continuous block of memory (array) by definition. std::string<...> guarantees to manage a continuous block of memory (array) by definition. SharedArray<...> and Array<...> classes (from fetch::memory namespace) that guarantee to manage a continuous block of memory (array) by definition. Classes from fetch::byte_array namespac, such as BasicByteArray","title":"Handling dynamically allocated MEMORY resources"},{"location":"ledger/style-guide/#transfer-between-ownership-models","text":"It is safe to transfer ownership from std::unique_ptr to std::shared_ptr . However, do NOT transfer ownership the other way around, i.e. from std::shared_ptr to std::unique_ptr . Any justification for doing this is highly questionable. If you really feel it is necessary to do this, then keep the following in mind: It is a non -trivial operation. The shared_ptr type is NOT designed for this. If you still want to proceed, then read this which may provide some guidance. Example of using smart pointer with shared ownership: #include <memory> #include <iostream> //* Parent Scope block { std :: shared_ptr < int > a0 ; //* Nested scope block { std :: shared_ptr < int > a1 = std :: make_shared < int > ( 5 ); //* refcount=1 a0 = a1 ; //* The `a1` instance become shared at this point (refcount=2) //* BOTH instances are valid, controlling the same `int` instance: std :: cout << \"a0 = \" << * a0 << \", a1 = \" << * a1 << std :: endl ; throw std :: exception (); //* The exception will cause stack unwinding, during which //* is the destructor of `a1` instance called automatically, //* what decrements refcount of shared object (to 1). //* At this point, the `a0` shared object is controlling lifecycle //* of the `int` instance created above in this scope. } //* We are still in stack unwinding process here (due to earlier exception), //* during which automatically called destructor of `a0` instance decrements //* refcount of shared object (to 0), what finally results to destruction of //* the `int` instance allocated & initialised in the nested scope above. } Example of using smart pointer with exclusive ownership: #include <memory> //* Parent Scope block { std :: unique_ptr < int > a0 ; //* Nested scope block { std :: unique_ptr < int > a1 = std :: make_unique < int > ( 5 ); a0 = a1 ; //* Transfer of OWNERSHIP from `a1` to `a0` //* The `a1` does NOT control lifecycle of the `int` instance anymore. //* This WILL result to throwing an exception since `a1` instance //* is initialised to `nullptr`: std :: cout << \"a1=\" << * a1 << std :: endl ; //* Automatically called destructor of `a1` instance, //* which does NOTHING since `a1` does NOT possess //* control over any object. } //* At this point, The `a0` variable is still controlling life-cycle of the //* `int` instance created in nested scope above. //* Automatically called destructor of `a0` instance will //* result to destruction of the `int` instance allocated & initialised //* in the nested scope above. }","title":"Transfer between ownership models"},{"location":"oef/","text":"The Open Economic Framework is the Fetch.AI decentralised virtual environment that supplies and supports APIs for autonomous third-party software agents, also known as Autonomous Economic Agents (AEAs). Autonomous Economic Agents are digital entities that run complex dynamic decision-making algorithms for application owners and clients. The Fetch.AI blockchain ledger ensures the truth and integrity of the entire system. The OEF documentation will show you how to build and register an agent, how to advertise and search for services, and explain how the negotiation protocol works. We have detailed API documentation in Python and a set of working examples you can try out. But before you can do anything at all, you need to be running a node. Let's get that sorted right away.","title":"What is the OEF?"},{"location":"oef/advertising/","text":"// Popup window code function newPopup(url) { popupWindow = window.open( url,'popUpWindow','height=600px,width=900px,left=500,top=60,resizable=yes,scrollbars=yes,toolbar=yes,menubar=yes,location=no,directories=no,status=no') } Agents advertise their services with schemas. Schemas describe services in a language agnostic manner, after which they are serialised by the SDK. Defining schemas A schema describes an agent, service, or resource with a set of attributes . To specify data models and descriptions in Python use the oef.schema module . Attributes An attribute is an abstract definition of a property. It is identified by a name that must be unique in a given schema. Each attribute has a type which specifies possible values. Currently, we support the following attribute types: strings integers booleans floats locations (latitude, longitude) An attribute of a schema can be optional in the case where an attribute is inapplicable. Attributes can also have descriptions. Let's look at a bookshop scenario. A bookshop may like to include the following properties of its books as attributes in the SDK: title author genre (e.g. science fiction, horror) year of publication average rating (average of the ratings between 0 and 5) ISBN code Whether it is available as e-book. For example, in Python, using the AttributeSchema class, we instantiate Attributes with attribute name, type, whether it is a required attribute, and a description: from oef.schema import AttributeSchema , Location attr_title = AttributeSchema ( \"title\" , str , True , \"The title of the book.\" ) attr_author = AttributeSchema ( \"author\" , str , True , \"The author of the book.\" ) attr_genre = AttributeSchema ( \"genre\" , str , True , \"The genre of the book.\" ) attr_year = AttributeSchema ( \"year\" , int , True , \"The year of publication of the book.\" ) attr_avg_rat = AttributeSchema ( \"average_rating\" , float , False , \"The average rating of the book.\" ) attr_isbn = AttributeSchema ( \"ISBN\" , str , True , \"The ISBN.\" ) attr_ebook = AttributeSchema ( \"ebook_available\" , bool , False , \"If the book can be sold as an e-book.\" ) attr_bookshop = AttributeSchema ( \"bookshop_pos\" , Location , False , \"The location of the bookshop where you can find the book\" ) Data model A DataModel is a set of attributes . Let's group the book attributes into a DataModel called book . In Python, this looks like this: from oef.schema import DataModel book_model = DataModel ( \"book\" , [ attr_title , attr_author , attr_genre , attr_year , attr_avg_rat , attr_isbn , attr_ebook , attr_bookshop ], \"A data model to describe books.\" ) A DataModel class requires a name, a list of attributes, and an optional description. Description A Description is an instantiated data model. Instantiated Description classes for the bookshop may look like this: from oef.schema import Description It = Description ({ \"title\" : \"It\" , \"author\" : \"Stephen King\" , \"genre\" : \"horror\" , \"year\" : 1986 , \"average_rating\" : 4.5 , \"ISBN\" : \"0-670-81302-8\" , \"ebook_available\" : True , \"bookshop_pos\" : Location ( 52.2057092 , 0.1183431 ) }, book_model ) _1984 = Description ({ \"title\" : \"1984\" , \"author\" : \"George Orwell\" , \"genre\" : \"novel\" , \"year\" : 1949 , \"ISBN\" : \"978-0451524935\" , \"ebook_available\" : False }, book_model ) Attributes are instantiated as part of a Description using a dictionary where: key = the name of the attributes. value = the values associated with the attribute key. Note that in the latter book we were able to omit the average_rating field because it was optional. In the oef-sdk-python/examples/weather folder, you will find the weather_schema.py file describing the data advertised by a weather service. from oef.schema import DataModel , AttributeSchema WIND_SPEED_ATTR = AttributeSchema ( \"wind_speed\" , bool , is_attribute_required = True , attribute_description = \"Provides wind speed measurements.\" ) TEMPERATURE_ATTR = AttributeSchema ( \"temperature\" , bool , is_attribute_required = True , attribute_description = \"Provides temperature measurements.\" ) AIR_PRESSURE_ATTR = AttributeSchema ( \"air_pressure\" , bool , is_attribute_required = True , attribute_description = \"Provides air pressure measurements.\" ) HUMIDITY_ATTR = AttributeSchema ( \"humidity\" , bool , is_attribute_required = True , attribute_description = \"Provides humidity measurements.\" ) WEATHER_DATA_MODEL = DataModel ( \"weather_data\" , [ WIND_SPEED_ATTR , TEMPERATURE_ATTR , AIR_PRESSURE_ATTR , HUMIDITY_ATTR ], \"All possible weather data.\" ) The WeatherStation class in the same directory, implements the behaviour of the weather station by creating a service description that mirrors the schema. weather_service_description = Description ( { \"wind_speed\" : False , \"temperature\" : True , \"air_pressure\" : True , \"humidity\" : True , }, WEATHER_DATA_MODEL ) Searching for schemas Agents searching for services do not have to match the advertised schema precisely as the OEF executes a fuzzy search algorithm/learned matching.","title":"Advertising"},{"location":"oef/advertising/#defining-schemas","text":"A schema describes an agent, service, or resource with a set of attributes . To specify data models and descriptions in Python use the oef.schema module .","title":"Defining schemas"},{"location":"oef/advertising/#attributes","text":"An attribute is an abstract definition of a property. It is identified by a name that must be unique in a given schema. Each attribute has a type which specifies possible values. Currently, we support the following attribute types: strings integers booleans floats locations (latitude, longitude) An attribute of a schema can be optional in the case where an attribute is inapplicable. Attributes can also have descriptions. Let's look at a bookshop scenario. A bookshop may like to include the following properties of its books as attributes in the SDK: title author genre (e.g. science fiction, horror) year of publication average rating (average of the ratings between 0 and 5) ISBN code Whether it is available as e-book. For example, in Python, using the AttributeSchema class, we instantiate Attributes with attribute name, type, whether it is a required attribute, and a description: from oef.schema import AttributeSchema , Location attr_title = AttributeSchema ( \"title\" , str , True , \"The title of the book.\" ) attr_author = AttributeSchema ( \"author\" , str , True , \"The author of the book.\" ) attr_genre = AttributeSchema ( \"genre\" , str , True , \"The genre of the book.\" ) attr_year = AttributeSchema ( \"year\" , int , True , \"The year of publication of the book.\" ) attr_avg_rat = AttributeSchema ( \"average_rating\" , float , False , \"The average rating of the book.\" ) attr_isbn = AttributeSchema ( \"ISBN\" , str , True , \"The ISBN.\" ) attr_ebook = AttributeSchema ( \"ebook_available\" , bool , False , \"If the book can be sold as an e-book.\" ) attr_bookshop = AttributeSchema ( \"bookshop_pos\" , Location , False , \"The location of the bookshop where you can find the book\" )","title":"Attributes"},{"location":"oef/advertising/#data-model","text":"A DataModel is a set of attributes . Let's group the book attributes into a DataModel called book . In Python, this looks like this: from oef.schema import DataModel book_model = DataModel ( \"book\" , [ attr_title , attr_author , attr_genre , attr_year , attr_avg_rat , attr_isbn , attr_ebook , attr_bookshop ], \"A data model to describe books.\" ) A DataModel class requires a name, a list of attributes, and an optional description.","title":"Data model"},{"location":"oef/advertising/#description","text":"A Description is an instantiated data model. Instantiated Description classes for the bookshop may look like this: from oef.schema import Description It = Description ({ \"title\" : \"It\" , \"author\" : \"Stephen King\" , \"genre\" : \"horror\" , \"year\" : 1986 , \"average_rating\" : 4.5 , \"ISBN\" : \"0-670-81302-8\" , \"ebook_available\" : True , \"bookshop_pos\" : Location ( 52.2057092 , 0.1183431 ) }, book_model ) _1984 = Description ({ \"title\" : \"1984\" , \"author\" : \"George Orwell\" , \"genre\" : \"novel\" , \"year\" : 1949 , \"ISBN\" : \"978-0451524935\" , \"ebook_available\" : False }, book_model ) Attributes are instantiated as part of a Description using a dictionary where: key = the name of the attributes. value = the values associated with the attribute key. Note that in the latter book we were able to omit the average_rating field because it was optional. In the oef-sdk-python/examples/weather folder, you will find the weather_schema.py file describing the data advertised by a weather service. from oef.schema import DataModel , AttributeSchema WIND_SPEED_ATTR = AttributeSchema ( \"wind_speed\" , bool , is_attribute_required = True , attribute_description = \"Provides wind speed measurements.\" ) TEMPERATURE_ATTR = AttributeSchema ( \"temperature\" , bool , is_attribute_required = True , attribute_description = \"Provides temperature measurements.\" ) AIR_PRESSURE_ATTR = AttributeSchema ( \"air_pressure\" , bool , is_attribute_required = True , attribute_description = \"Provides air pressure measurements.\" ) HUMIDITY_ATTR = AttributeSchema ( \"humidity\" , bool , is_attribute_required = True , attribute_description = \"Provides humidity measurements.\" ) WEATHER_DATA_MODEL = DataModel ( \"weather_data\" , [ WIND_SPEED_ATTR , TEMPERATURE_ATTR , AIR_PRESSURE_ATTR , HUMIDITY_ATTR ], \"All possible weather data.\" ) The WeatherStation class in the same directory, implements the behaviour of the weather station by creating a service description that mirrors the schema. weather_service_description = Description ( { \"wind_speed\" : False , \"temperature\" : True , \"air_pressure\" : True , \"humidity\" : True , }, WEATHER_DATA_MODEL )","title":"Description"},{"location":"oef/advertising/#searching-for-schemas","text":"Agents searching for services do not have to match the advertised schema precisely as the OEF executes a fuzzy search algorithm/learned matching.","title":"Searching for schemas"},{"location":"oef/java-kotlin-API/","text":"// Popup window code function newPopup(url) { popupWindow = window.open( url,'popUpWindow','height=600px,width=900px,left=500,top=60,resizable=yes,scrollbars=yes,toolbar=yes,menubar=yes,location=no,directories=no,status=no') } Click here for the API.","title":"Java/Kotlin"},{"location":"oef/negotiating/","text":"The way Agents communicate is fundamentally different to the object-oriented paradigm. Instead of calling Agents directly, communication between Agents is more akin to human language exchanges such as in bartering scenarios. Quote Objects do it for free; agents do it because they want to. FIPA (Foundation for Intelligent Physical Agents) is a well known standard for agent negotiation. In the OEF, communication follows a minimal subset of the FIPA language. For instance: Buying Agent b requests a resource r from Selling Agent s by sending a call for proposal cfp(r) . Selling Agent s replies by sending a proposal to b with propose(r, p) , where r is the resource requested and p is the seller\u2019s asking price. Specifically, the negotiation system has the following components: A set of speech-acts where each item may also be called a locution: {cfp(r), propose(r,p), accept(), decline()} A reply structure, where each locution is only a valid reply to some other locutions. This is denoted in the following table: Locution Could reply to cfp(r) propose(r,p) cfp(r) or propose(r,p) accept() propose(r,p) decline() cfp(r) A set of moves where each move has the following format: id sender speech-act target Where id is the identity of the move in a dialogue, sender is the agent who sends this move, speech-act is the actual content of the move (i.e. its locution) and target is the id of the move this move is replying to. A dialogue is then just a sequence of moves, where the first move\u2019s target is 0 (the first move is not replying to any other move in the dialogue). An example of a simple negotiation between a buying Agent b and selling Agent s over the resource r is as follows: id Agent locution target 1 b cfp(r) 0 2 s propose(r, 20) 1 3 b propose(r, 10) 2 4 s propose(r, 15) 3 5 b accept() 4 Note the following simple protocol rules: The negotiation dialogues always start with a cfp(r) move. A dialogue terminates when an accept() or decline() is sent. Agents take turns to send moves in the dialogue. In other words, one agent could only send one move in its turn and has to wait for a response from the other agent before being able to send another move. Agents can only reply to the move of the other agent, and not their own. Current implementation In the current version of the OEF SDK, callbacks tell Agents which step of the FIPA protocol has occurred. For example, Agent Alice sends a sendCFP (call for proposal) message containing the public key and query to Agent Bob via the OEF which forwards an onCFP . Agent Bob receives the onCFP event and replies with a sendPropose containing a list of proposals. Bob's sendPropose has the same identifier that came with the onCFP . This means that Alice can refer back to the CFP when she gets the onPropose event. onACK and onDeal finalise the communication (more). Finally, Agent Alice receives the byte payload from Agent Bob on sendMessage . Every message contains the following: dialogue id : the identifier of the dialogue in which the message is sent. destination : the agent identifier to whom the message is sent. message id : the message identifier for the dialogue. target : the identifier of the message to whom this message is answering.","title":"Negotiating"},{"location":"oef/negotiating/#current-implementation","text":"In the current version of the OEF SDK, callbacks tell Agents which step of the FIPA protocol has occurred. For example, Agent Alice sends a sendCFP (call for proposal) message containing the public key and query to Agent Bob via the OEF which forwards an onCFP . Agent Bob receives the onCFP event and replies with a sendPropose containing a list of proposals. Bob's sendPropose has the same identifier that came with the onCFP . This means that Alice can refer back to the CFP when she gets the onPropose event. onACK and onDeal finalise the communication (more). Finally, Agent Alice receives the byte payload from Agent Bob on sendMessage . Every message contains the following: dialogue id : the identifier of the dialogue in which the message is sent. destination : the agent identifier to whom the message is sent. message id : the message identifier for the dialogue. target : the identifier of the message to whom this message is answering.","title":"Current implementation"},{"location":"oef/public-key/","text":"A valid public key in the OEF contains only Base58 characters, which consist of alphanumeric characters, excluding the following characters: 0 (zero), O (capital o), I (capital i) and l (lower case L). Generate a public key for your Agent with the crypto.py script which uses the Python cryptography library. Simply instantiate a Crypto object and call the public_key() function. @property def public_key ( self ) -> str : \"\"\" Returns a 219 character public key in base58 format \"\"\" return self . _public_key_b58 The library generates a private key and the function returns a Base58 public key string. Calling public_key() again returns the same public key. In the same script, there are data verification and signing functions. The sign_data() function takes a serialized byte stream of data, signs it, and returns signed data as an immutable sequence of bytes. def sign_data ( self , data : bytes ) -> bytes : \"\"\" Sign data with your own private key. :param data: the data to sign :return: the signature \"\"\" digest = self . _hash_data ( data ) signature = self . _private_key . sign ( digest , ec . ECDSA ( utils . Prehashed ( self . _chosen_hash ))) return signature The is_confirmed_integrity() function verifies signed data against a signature and a public key. def is_confirmed_integrity ( self , data : bytes , signature : bytes , signer_pbk : str ) -> bool : \"\"\" Confirrms the integrity of the data with respect to its signature. :param data: the data to be confirmed :param signature: the signature associated with the data :param signer_pbk: the public key of the signer :return: bool indicating whether the integrity is confirmed or not \"\"\" signer_pbk = self . _pbk_to_obj ( signer_pbk ) digest = self . _hash_data ( data ) try : signer_pbk . verify ( signature , digest , ec . ECDSA ( utils . Prehashed ( self . _chosen_hash ))) return True except CryptoError as e : logger . exception ( str ( e )) return False","title":"Get a public key"},{"location":"oef/python-API/","text":"// Popup window code function newPopup(url) { popupWindow = window.open( url,'popUpWindow','height=600px,width=900px,left=500,top=60,resizable=yes,scrollbars=yes,toolbar=yes,menubar=yes,location=no,directories=no,status=no') } Click here for the API.","title":"Python"},{"location":"oef/registering/","text":"Agents register to and deregister from the OEF. Before an Agent can advertise or search for services, it must register to the OEF. Agents are created with a name and public key and they connect to the OEF with an OEF host and port number. On attempting to connect to the OEF, the public key is verified. Role names An Agent can perform several roles at once. In order to distinguish between roles, an Agent supplies a different name for each role. This means that an agent could advertise several services using the same public key but different roles names, such as in this example: Public key and role name Data members advertised DEADBEEF/newspaper_seller available_newspaper_list available_magazine_list DEADBEEF/refuelling_station petrol_availability diesel_availability When an Agent conducts a search, it receives the public key and the role name of Agent(s) who are advertising matching services. A role name can be empty. This is the default case and can be used for simple Agent setups. In order to talk to Agents with multiple services, we use a Context which contains source and target information for every message. The target information, key and role, references the receiving Agent. Similarly the source information references the sending Agent. To send a reply the other way, the two parts can simply be swapped.","title":"Registering"},{"location":"oef/registering/#role-names","text":"An Agent can perform several roles at once. In order to distinguish between roles, an Agent supplies a different name for each role. This means that an agent could advertise several services using the same public key but different roles names, such as in this example: Public key and role name Data members advertised DEADBEEF/newspaper_seller available_newspaper_list available_magazine_list DEADBEEF/refuelling_station petrol_availability diesel_availability When an Agent conducts a search, it receives the public key and the role name of Agent(s) who are advertising matching services. A role name can be empty. This is the default case and can be used for simple Agent setups. In order to talk to Agents with multiple services, we use a Context which contains source and target information for every message. The target information, key and role, references the receiving Agent. Similarly the source information references the sending Agent. To send a reply the other way, the two parts can simply be swapped.","title":"Role names"},{"location":"oef/running-a-node/","text":"First, get Docker . Next, pull and launch our published image. docker pull fetchai/oef-search:latest Now download the node_config.json file. And run the Docker image with the configuration. docker run -it -v ` pwd ` :/config -p 20000 :20000 -p 10000 :10000 -p 40000 :40000 -p 7500 fetchai/oef-search:latest node no_sh --config_file /config/node_config.json A successful run will start producing stats dumps after a few seconds. You'll need to have several ports available on your machine: 10000 , 20000 , 30000 , and 7500 . Now we have a node up and running, let's get the SDK.","title":"Running a node"},{"location":"oef/sdk/","text":"We will focus solely on Python SDK examples throughout the documentation. Python First, run the pip installation command: pip3 install -v -v -v --no-cache-dir oef After that, let's check we installed the SDK correctly: python3 from oef import agents When a function needs a core address, use 127.0.0.1 and port 10000 . Now download the working examples bundle .","title":"Get the SDK"},{"location":"oef/sdk/#python","text":"First, run the pip installation command: pip3 install -v -v -v --no-cache-dir oef After that, let's check we installed the SDK correctly: python3 from oef import agents When a function needs a core address, use 127.0.0.1 and port 10000 . Now download the working examples bundle .","title":"Python"},{"location":"oef/searching/","text":"Agent nodes search for services advertised by other Agents. The OEF manages the search process. In the example below, Agent Alice is looking for hotel rooms. Agent Bob is a node that has advertised hotel booking services. The OEF matches them up. Agent Alice is a node connected to the OEF 001 . She wants to book a hotel room and sends a search request to the OEF. Exactly what a search looks like is up to the agent. In this case, a search should contain the rough location and other specifics. For example, a hotel room provider may advertise a schema containing room availability , parking available , breakfast included , etc. The OEF nodes communicate with each other to find suitable matching agents. Agent Bob looks ideal. OEF 001 returns a list of Agents, their IDs, the OEF node they're attached to, and how to reach it, i.e. an IP address or hostname and port number. Alice decides to talk to Bob. She connects to a shared OEF 078 with the host and port combination she received. At connection time, Alice supplies her ID and answers a verification challenge given by the OEF. Agent Alice verifies successfully and OEF 078 starts talking to Alice. Alice can now ask the OEF to send a message to Bob on her behalf. She uses the ID from the search results as the target and adds her message; in this case a suitable CFP (Call For Proposal) to initiate a conversation with Bob. The OEF sends Alice's message on to Bob along with any other messages Bob is currently receiving from other agents. Wide and narrow searches There are two types of search the OEF supports, wide and narrow searches. A wide search will generate results from Agents not directly connected to the search initiating Agent. A narrow search will only generate results from Agents connected directly to the same OEF node. For example, in the following diagram, when Charlene does a wide search, results come back from Alice, Bob, and Damian. When Charlene does a narrow search, she only gets results from Damian. Query language The Query API allows you to: Query the OEF Node about specific kind of services. Query other agents to ask them about desired resources. A query is a set of constraints , defined over a data model . The outcome is a set of descriptions matching the query. In the next sections, we describe how to build queries with the Python SDK. Constraints A constraint is associated with an attribute name and imposes limitations on the values the attribute can assume. There are different types of constraints: relation The author of the book must be Stephen King . The publication year must be greater than 1990. set The genre must fall into the following set of genres: Horror , Science fiction , Non-fiction . range The average rating must be between 3.5 and 4.5. distance The nearest bookshop must be within a distance from a given location. The following descriptions and Python examples take you through the query constraint types: Relation Equal Not equal Less than Less than or equal Greater than Greater than or equal from oef.query import Constraint , Eq , NotEq , Lt , LtEq , Gt , GtEq # all the books whose author is Stephen King Constraint ( \"author\" , Eq ( \"Stephen King\" )) # all the books that are not of the genre Horror Constraint ( \"genre\" , NotEq ( \"Horror\" )) # all the books published before 1990 Constraint ( \"year\" , Lt ( 1990 )) # the same of before, but including 1990 Constraint ( \"year\" , LtEq ( 1990 )) # all the books with rating greater than 4.0 Constraint ( \"average_rating\" , Gt ( 4.0 )) # all the books published after 2000, included Constraint ( \"year\" , GtEq ( 2000 )) Set Set is a constraint type that allows you to restrict the values of the attribute in a specific set. There are two kind of Set constraints: In (a set of values) Not in (a set of values) from oef.query import Constraint , In , NotIn # all the books whose genre is one of `Horror`, `Science fiction`, `Non-fiction` Constraint ( \"genre\" , In ([ \"horror\" , \"science fiction\" , \"non-fiction\" ])) # all the books that have not been published neither in 1990, nor in 1995, nor in 2000 Constraint ( \"year\" , NotIn ([ 1990 , 1995 , 2000 ])) Range Range is a constraint type that allows you to restrict the values of the attribute within a given range. from oef.query import Constraint , Range # all the books whose title is between 'A' and 'B' (alphanumeric order) Constraint ( \"title\" , Range (( \"A\" , \"B\" ))) # all the books that have been published between 1960 and 1970 Constraint ( \"genre\" , Range (( 1960 , 1970 )) Distance Distance is a constraint type that allows you to put a limit on a Location . More specifically, you can set a maximum distance from a given location (the center ). from oef.query import Constraint , Distance from oef.schema import Location , Description # define a location of interest, e.g. the Tour Eiffel tour_eiffel = Location ( 48.8581064 , 2.29447 ) # find all the locations close to the Tour Eiffel within 1 km close_to_tour_eiffel = Constraint ( \"position\" , Distance ( tour_eiffel , 1.0 )) # Le Jules Verne, a famous restaurant close to the Tour Eiffel, satisfies the constraint. le_jules_verne_restaurant = Location ( 48.8579675 , 2.2951849 ) close_to_tour_eiffel . check ( Description ({ \"position\" : le_jules_verne_restaurant })) # gives `True` # The Colosseum does not satisfy the constraint (farther than 1 km from the Tour Eiffel). colosseum = Location ( 41.8902102 , 12.4922309 ) close_to_tour_eiffel . check ( Description ({ \"position\" : colosseum })) # gives `False` Constraint expressions The constraints above can be combined with common logical operators, i.e. and , or , and not using he Not , And , and Or classes. In particular we can specify any conjunction, disjunction, or negation of the previous constraints or composite constraint expression(s). For example: Books that belong to Horror genre and were published after 2000 but not authored by Stephen King . Books whose author is either J. K. Rowling or J. R. R. Tolkien . Not Not allows you to specify a negation of a constraint expression. from oef.query import Constraint , Not , Range # all the books whose year of publication is not between 1990 and 2000 Not ( Constraint ( \"year\" , Range (( 1990 , 2000 ))) And And allows you to specify a conjunction of constraints over an attribute. There must be at least 2 sub-expressions. from oef.query import Constraint , And , NotEq , Range # all the books whose title is between 'I' and 'J' (alphanumeric order) but not equal to 'It' And ([ Constraint ( \"title\" , Range (( \"I\" , \"J\" ))), Constraint ( \"title\" , NotEq ( \"It\" ))]) Or Or allows you to specify a disjunction of constraints. The number of sub-expressions must be at least 2. from oef.query import Constraint , Or , Lt , Gt # all the books that have been published either before the year 1960 or after the year 1970 Or ([ Constraint ( \"year\" , Lt ( 1960 )), Constraint ( \"year\" , Gt ( 1970 ))]) Queries A query is a list of constraint expressions . from oef.query import Query , Constraint , Eq , Gt , Eq # return all the books written by Stephen King published after 1990, and available as an e-book: Query ([ Constraint ( \"author\" , Eq ( \"Stephen King\" )), Constraint ( \"year\" , Gt ( 1990 )), Constraint ( \"ebook_available\" , Eq ( True )) ], book_model ) Where book_model is the DataModel object. Although the DataModel is an optional parameter, we recommended including it. The check method The check method checks whether a Description matches the Query . from oef.query import Query , Constraint , Eq , Gt , Eq from oef.schema import Description q = Query ([ Constraint ( \"author\" , Eq ( \"Stephen King\" )), Constraint ( \"year\" , Gt ( 1990 )), Constraint ( \"ebook_available\" , Eq ( True )) ]) # With a query, you can check that a `~oef.schema.Description` object satisfies the constraints. q . check ( Description ({ \"author\" : \"Stephen King\" , \"year\" : 1991 , \"ebook_available\" : True })) # True q . check ( Description ({ \"author\" : \"George Orwell\" , \"year\" : 1948 , \"ebook_available\" : False })) # False Validity A Query object must satisfy some conditions before it can be instantiated. There must be at least one constraint expression. If the data model is specified, then each constraint expression much be validated against the data model. A ConstraintExpr c is valid with respect to a DataModel according to the following: If c is an instance of And , Or , or Not , then every subexpression of c must be valid with respect to the data model. If c is an instance of Constraint , then: if the constraint type is one of Lt , LtEq , Gt , or GtEq , the value in the constructor must be str , int , or float . if the constraint type is a Range , then the types in the range must be int , str , float , or Location . if the constraint type is a Distance , then the only valid type is Location . if the constraint type is a Set , then the types supported are str , int , float , bool , Location . Notice that a set of bool is trivial, so you may find yourself more comfortable using an alternative. for the other constraint types, i.e. Eq and NotEq , the value can be one of the allowed types for AttributeSchema , that is str , int , float , bool , Location . Moreover, when c is a Constraint , the attribute must have a consistent type with regards to the data model. For example: Constraint ( \"foo\" , Eq ( True ))) Consider a DataModel where there is an AttributeSchema foo of type str . Then the constraint is not compatible with the mentioned data model, because the constraint expects an equality comparison with a boolean True , instead of a str .","title":"Searching"},{"location":"oef/searching/#wide-and-narrow-searches","text":"There are two types of search the OEF supports, wide and narrow searches. A wide search will generate results from Agents not directly connected to the search initiating Agent. A narrow search will only generate results from Agents connected directly to the same OEF node. For example, in the following diagram, when Charlene does a wide search, results come back from Alice, Bob, and Damian. When Charlene does a narrow search, she only gets results from Damian.","title":"Wide and narrow searches"},{"location":"oef/searching/#query-language","text":"The Query API allows you to: Query the OEF Node about specific kind of services. Query other agents to ask them about desired resources. A query is a set of constraints , defined over a data model . The outcome is a set of descriptions matching the query. In the next sections, we describe how to build queries with the Python SDK.","title":"Query language"},{"location":"oef/searching/#constraint-expressions","text":"The constraints above can be combined with common logical operators, i.e. and , or , and not using he Not , And , and Or classes. In particular we can specify any conjunction, disjunction, or negation of the previous constraints or composite constraint expression(s). For example: Books that belong to Horror genre and were published after 2000 but not authored by Stephen King . Books whose author is either J. K. Rowling or J. R. R. Tolkien .","title":"Constraint expressions"},{"location":"oef/searching/#queries","text":"A query is a list of constraint expressions . from oef.query import Query , Constraint , Eq , Gt , Eq # return all the books written by Stephen King published after 1990, and available as an e-book: Query ([ Constraint ( \"author\" , Eq ( \"Stephen King\" )), Constraint ( \"year\" , Gt ( 1990 )), Constraint ( \"ebook_available\" , Eq ( True )) ], book_model ) Where book_model is the DataModel object. Although the DataModel is an optional parameter, we recommended including it.","title":"Queries"},{"location":"oef/searching/#validity","text":"A Query object must satisfy some conditions before it can be instantiated. There must be at least one constraint expression. If the data model is specified, then each constraint expression much be validated against the data model. A ConstraintExpr c is valid with respect to a DataModel according to the following: If c is an instance of And , Or , or Not , then every subexpression of c must be valid with respect to the data model. If c is an instance of Constraint , then: if the constraint type is one of Lt , LtEq , Gt , or GtEq , the value in the constructor must be str , int , or float . if the constraint type is a Range , then the types in the range must be int , str , float , or Location . if the constraint type is a Distance , then the only valid type is Location . if the constraint type is a Set , then the types supported are str , int , float , bool , Location . Notice that a set of bool is trivial, so you may find yourself more comfortable using an alternative. for the other constraint types, i.e. Eq and NotEq , the value can be one of the allowed types for AttributeSchema , that is str , int , float , bool , Location . Moreover, when c is a Constraint , the attribute must have a consistent type with regards to the data model. For example: Constraint ( \"foo\" , Eq ( True ))) Consider a DataModel where there is an AttributeSchema foo of type str . Then the constraint is not compatible with the mentioned data model, because the constraint expects an equality comparison with a boolean True , instead of a str .","title":"Validity"},{"location":"smart-contracts/data-types/","text":"The etch language provides a number of object types and functions designed specifically with smart contract development in mind. We detail these in the etch language guide but here's an overview. State A State provides persistent storage for smart contracts. The data referenced by a State type resides on the ledger. State values are available for use in smart contract functions. Sharded State A ShardedState is like a State type in that data contained within a ShardedState also resides on the ledger and is available for use in smart contract functions. However, ShardedState is a map of key/value pairs so can wrap significantly more data under one reference. Moreover, ShardedState manages the sharded structure of ledger memory more efficiently than a State type. Address The Address data structure formats multiple cryptographic public key types and includes a number of useful functions such as verify() and existed() . Cryptographic functions Currently, we support the SHA256() function.","title":"Data types"},{"location":"smart-contracts/data-types/#state","text":"A State provides persistent storage for smart contracts. The data referenced by a State type resides on the ledger. State values are available for use in smart contract functions.","title":"State"},{"location":"smart-contracts/data-types/#sharded-state","text":"A ShardedState is like a State type in that data contained within a ShardedState also resides on the ledger and is available for use in smart contract functions. However, ShardedState is a map of key/value pairs so can wrap significantly more data under one reference. Moreover, ShardedState manages the sharded structure of ledger memory more efficiently than a State type.","title":"Sharded State"},{"location":"smart-contracts/data-types/#address","text":"The Address data structure formats multiple cryptographic public key types and includes a number of useful functions such as verify() and existed() .","title":"Address"},{"location":"smart-contracts/data-types/#cryptographic-functions","text":"Currently, we support the SHA256() function.","title":"Cryptographic functions"},{"location":"smart-contracts/executing-smart-contract-code/","text":"Executing smart contract code Locally To run smart contract code on your local machine, first download, build, and run a ledger node. You can find out how to do that here . If you have previously been running ledger constellation nodes, you should remove the databases as they will be incompatible with a fresh node. rm *.db Build the Python API libraries like this: pip3 install -U fetchai-ledger-api Simple transfer example in Python If you want to examine the code in more detail and look at some examples, you may prefer to clone or download the repo. git clone https://github.com/fetchai/ledger-api-py.git And run the installation script: python3 ledger-api-py/setup.py install In your favourite Python IDE, open the create_and_send.py script in the examples directory. This script creates two Entity objects, sets a balance of 1000 tokens on your_identity , and makes a transfer to other_identity . from fetchai.ledger.api import LedgerApi from fetchai.ledger.crypto import Identity , Entity HOST = '127.0.0.1' PORT = 8100 def main (): # create the APIs api = LedgerApi ( HOST , PORT ) # generate a random identity your_identity = Entity () other_identity = Entity () print ( 'Balance Before:' , api . tokens . balance ( your_identity )) # create the balance print ( 'Submitting wealth creation...' ) api . sync ( api . tokens . wealth ( your_identity , 1000 )) print ( 'Balance after wealth:' , api . tokens . balance ( your_identity )) # submit and wait for the transfer to be complete print ( 'Submitting transfer...' ) api . sync ( api . tokens . transfer ( your_identity , other_identity , 250 , 20 )) print ( 'Balance 1:' , api . tokens . balance ( your_identity )) print ( 'Balance 2:' , api . tokens . balance ( other_identity )) if __name__ == '__main__' : main () Tip Make sure you have the correct port number for the running ledger node. You should see the following results when running the script. Balance Before: 0 Submitting wealth creation... Balance after wealth: 1000 Submitting transfer... Balance 1 : 749 Balance 2 : 250 Embedding contract code Smart contract code is embedded into a Python script as a string. The smart contract below resembles the contracts.py script in the examples folder, except the State definitions are in line with etch updates. from fetchai.ledger.api import LedgerApi from fetchai.ledger.contract import SmartContract from fetchai.ledger.crypto import Entity , Address CONTRACT_TEXT = \"\"\" @init function setup(owner : Address) var owner_balance = State<UInt64>(owner); owner_balance.set(1000000u64); endfunction @action function transfer(from: Address, to: Address, amount: UInt64) // define the accounts var from_account = State<UInt64>(from); var to_account = State<UInt64>(to); // if new sets to 0u // Check if the sender has enough balance to proceed if (from_account.get(0u64) >= amount) // update the account balances from_account.set(from_account.get(0u64) - amount); to_account.set(to_account.get(0u64) + amount); endif endfunction @query function balance(address: Address) : UInt64 var account = State<UInt64>(address); return account.get(0u64); endfunction \"\"\" From here, you can create a Python SmartContract type and feed it the contract string. Then deploy the contract with the Python LedgerApi . The code below takes the CONTRACT_TEXT string above and deploys it to the ledger along with details of the contract owner and the fee. # create the smart contract contract = SmartContract ( CONTRACT_TEXT ) # deploy the contract to the network api . sync ( api . contracts . create ( owner , contract , 2000 )) Test network You can run the examples on our test network, replacing the hostname and port. HOST = 'bootstrap.fetch.ai' PORT = 80 However, you will need some FET tokens and an Address . We show you how to get some test FET and set up the Fetch Wallet in the next section. Public network Note In development.","title":"Executing smart contracts"},{"location":"smart-contracts/executing-smart-contract-code/#locally","text":"To run smart contract code on your local machine, first download, build, and run a ledger node. You can find out how to do that here . If you have previously been running ledger constellation nodes, you should remove the databases as they will be incompatible with a fresh node. rm *.db Build the Python API libraries like this: pip3 install -U fetchai-ledger-api","title":"Locally"},{"location":"smart-contracts/executing-smart-contract-code/#simple-transfer-example-in-python","text":"If you want to examine the code in more detail and look at some examples, you may prefer to clone or download the repo. git clone https://github.com/fetchai/ledger-api-py.git And run the installation script: python3 ledger-api-py/setup.py install In your favourite Python IDE, open the create_and_send.py script in the examples directory. This script creates two Entity objects, sets a balance of 1000 tokens on your_identity , and makes a transfer to other_identity . from fetchai.ledger.api import LedgerApi from fetchai.ledger.crypto import Identity , Entity HOST = '127.0.0.1' PORT = 8100 def main (): # create the APIs api = LedgerApi ( HOST , PORT ) # generate a random identity your_identity = Entity () other_identity = Entity () print ( 'Balance Before:' , api . tokens . balance ( your_identity )) # create the balance print ( 'Submitting wealth creation...' ) api . sync ( api . tokens . wealth ( your_identity , 1000 )) print ( 'Balance after wealth:' , api . tokens . balance ( your_identity )) # submit and wait for the transfer to be complete print ( 'Submitting transfer...' ) api . sync ( api . tokens . transfer ( your_identity , other_identity , 250 , 20 )) print ( 'Balance 1:' , api . tokens . balance ( your_identity )) print ( 'Balance 2:' , api . tokens . balance ( other_identity )) if __name__ == '__main__' : main () Tip Make sure you have the correct port number for the running ledger node. You should see the following results when running the script. Balance Before: 0 Submitting wealth creation... Balance after wealth: 1000 Submitting transfer... Balance 1 : 749 Balance 2 : 250","title":"Simple transfer example in Python"},{"location":"smart-contracts/executing-smart-contract-code/#embedding-contract-code","text":"Smart contract code is embedded into a Python script as a string. The smart contract below resembles the contracts.py script in the examples folder, except the State definitions are in line with etch updates. from fetchai.ledger.api import LedgerApi from fetchai.ledger.contract import SmartContract from fetchai.ledger.crypto import Entity , Address CONTRACT_TEXT = \"\"\" @init function setup(owner : Address) var owner_balance = State<UInt64>(owner); owner_balance.set(1000000u64); endfunction @action function transfer(from: Address, to: Address, amount: UInt64) // define the accounts var from_account = State<UInt64>(from); var to_account = State<UInt64>(to); // if new sets to 0u // Check if the sender has enough balance to proceed if (from_account.get(0u64) >= amount) // update the account balances from_account.set(from_account.get(0u64) - amount); to_account.set(to_account.get(0u64) + amount); endif endfunction @query function balance(address: Address) : UInt64 var account = State<UInt64>(address); return account.get(0u64); endfunction \"\"\" From here, you can create a Python SmartContract type and feed it the contract string. Then deploy the contract with the Python LedgerApi . The code below takes the CONTRACT_TEXT string above and deploys it to the ledger along with details of the contract owner and the fee. # create the smart contract contract = SmartContract ( CONTRACT_TEXT ) # deploy the contract to the network api . sync ( api . contracts . create ( owner , contract , 2000 ))","title":"Embedding contract code"},{"location":"smart-contracts/executing-smart-contract-code/#test-network","text":"You can run the examples on our test network, replacing the hostname and port. HOST = 'bootstrap.fetch.ai' PORT = 80 However, you will need some FET tokens and an Address . We show you how to get some test FET and set up the Fetch Wallet in the next section.","title":"Test network"},{"location":"smart-contracts/executing-smart-contract-code/#public-network","text":"Note In development.","title":"Public network"},{"location":"smart-contracts/executing-synergetic-code/","text":"Executing synergetic contract code Warning Synergetic contracts are currently an experimental feature. To test synergetic contracts, run a ledger node in synergetic mode using specific flags. ./constellation -standalone -block-interval 1000 -experimental synergetic,naive-synergetic-mining In the Python API examples folder, take a look at the synergetic.py script. import os import random import json from fetchai.ledger.api import LedgerApi from fetchai.ledger.crypto import Entity , Address from fetchai.ledger.contract import SynergeticContract CONTRACT_TEXT = \"\"\" @problem function createProblem(data : Array<StructuredData>) : Int32 var value = 0; for (i in 0:data.count() - 1) value += data[i].getInt32(\"value\"); endfor return value; endfunction @objective function evaluateWork(problem : Int32, solution : Int32 ) : Int64 return abs(toInt64(problem) - toInt64(solution)); endfunction @work function doWork(problem : Int32, nonce : BigUInt) : Int32 return nonce.toInt32(); endfunction @clear function applyWork(problem : Int32, solution : Int32) var result = State<Int32>(\"solution\", 0); result.set(solution); endfunction \"\"\" def main (): # create the API api = LedgerApi ( '127.0.0.1' , 8100 ) # create an entity and provide it some wealth print ( 'Setup...' ) entity = Entity () api . sync ( api . tokens . wealth ( entity , 100000000 )) print ( 'Setup...complete' ) # create the contract on the ledger synergy_contract = SynergeticContract ( CONTRACT_TEXT ) print ( synergy_contract . digest ) api . sync ( api . contracts . create ( entity , synergy_contract , 4096 )) # create a whole series of random data to submit to the DAG random_ints = [ random . randint ( 0 , 200 ) for _ in range ( 4000 )] api . sync ([ api . synergetic . submit_data ( entity , synergy_contract . digest , value = value ) for value in random_ints ]) if __name__ == '__main__' : main () In the synergetic contract example above, the @problem function sets up a calculation over an array and returns the value. The @objective function evaluates the work done on the problem giving a measure as to how close the current solution is to the correct result. The @doWork function returns a nonce to kick start the calculations. The @clear function tidies up once a solution has been found and saves the correct result to the ledger.","title":"Executing synergetic contracts"},{"location":"smart-contracts/memory/","text":"Memory State and ShardedState store data on the shards that make up the ledger. There are a configurable number of parallel shards on the ledger that accept permanent, irreversible storage. Developers have to pay to store data on ledger shards so they should take care when constructing State and ShardedState types to avoid unnecessary fees. Ensuring that smart contract data is evenly spread across ledger shards is the most efficient and economical way to code and execute smart contracts in etch . The trick is to ensure that etch code avoids taking up too much memory on a single shard or taking up too much memory on too many shards as more memory costs more to deploy. It is possible to exceed etch imposed limits on data storage in which case an etch smart contract will fail. Design considerations You can visualise the ledger shards as a series of swim lanes. Data etches onto a shard depending on the smart contract design. The contents of a State etch onto a single shard on the ledger. For example, function main () var myState1 = State < Int32 > ( \"balance\" ); myState1 . set ( 200 ); endfunction The above integer value may etch onto a shard like this: This is an economical way to manage memory on the ledger shards. However, there are scenarios in which State data etches onto the ledger in an inefficient way. Aggregate functions may store too much data on too many shards on the ledger if coded inappropriately. Code like this can block other users and slow the network. Data fees will reflect this. For example, given a vote() function such as the one below, the code may aggregate the vote tracking State variables in an inefficient manner. function main () vote (); endfunction function vote () // declare and set politics account var race_for_prime_minister = \"hustings\" ; var votes_for = State < Int32 > ( race_for_prime_minister ); votes_for . set ( 0 ); var votes_against = State < Int32 > ( race_for_prime_minister ); votes_against . set ( 0 ); var votes_total = State < Int32 > ( race_for_prime_minister ); votes_total . set ( 0 ); var votes_sum = State < Int32 > ( race_for_prime_minister ); votes_sum . set ( 0 ); // ..and further along.. if ( true ) // update the aggregate votes for votes_for . set ( votes_for . get () + 1 ); else // update the aggregate votes against votes_against . set ( votes_against . get () + 1 ); endif // update the aggregate of total votes votes_sum . set ( votes_total . get () + 1 ); endfunction Each time a State increments, the new data value takes up a new memory space on the shard. The ledger shards could look something like this after the vote() function runs over a short period of time. This is highly uneconomical. Every aggregate value for a single State takes up its own spot on a ledger shard. Furthermore, multiple States take up multiple shards. Data is chargeable per lane in order to disincentivise code like the above which can slow the network. There are better approaches to the voting problem. For example, by encapsulating the data with a ShardedState and performing calculations in functions outside the ledger. function main () vote (); endfunction function vote () var fors = ShardedState < Int32 > ( \"votes_for\" ); fors . set ( \"Alice\" , increment ( fors . get ( \"Alice\" , 0 ))); // etc. endfunction function increment ( x : Int32 ) : Int32 var y = x + 1 ; return y ; endfunction","title":"Memory"},{"location":"smart-contracts/memory/#design-considerations","text":"You can visualise the ledger shards as a series of swim lanes. Data etches onto a shard depending on the smart contract design. The contents of a State etch onto a single shard on the ledger. For example, function main () var myState1 = State < Int32 > ( \"balance\" ); myState1 . set ( 200 ); endfunction The above integer value may etch onto a shard like this: This is an economical way to manage memory on the ledger shards. However, there are scenarios in which State data etches onto the ledger in an inefficient way. Aggregate functions may store too much data on too many shards on the ledger if coded inappropriately. Code like this can block other users and slow the network. Data fees will reflect this. For example, given a vote() function such as the one below, the code may aggregate the vote tracking State variables in an inefficient manner. function main () vote (); endfunction function vote () // declare and set politics account var race_for_prime_minister = \"hustings\" ; var votes_for = State < Int32 > ( race_for_prime_minister ); votes_for . set ( 0 ); var votes_against = State < Int32 > ( race_for_prime_minister ); votes_against . set ( 0 ); var votes_total = State < Int32 > ( race_for_prime_minister ); votes_total . set ( 0 ); var votes_sum = State < Int32 > ( race_for_prime_minister ); votes_sum . set ( 0 ); // ..and further along.. if ( true ) // update the aggregate votes for votes_for . set ( votes_for . get () + 1 ); else // update the aggregate votes against votes_against . set ( votes_against . get () + 1 ); endif // update the aggregate of total votes votes_sum . set ( votes_total . get () + 1 ); endfunction Each time a State increments, the new data value takes up a new memory space on the shard. The ledger shards could look something like this after the vote() function runs over a short period of time. This is highly uneconomical. Every aggregate value for a single State takes up its own spot on a ledger shard. Furthermore, multiple States take up multiple shards. Data is chargeable per lane in order to disincentivise code like the above which can slow the network. There are better approaches to the voting problem. For example, by encapsulating the data with a ShardedState and performing calculations in functions outside the ledger. function main () vote (); endfunction function vote () var fors = ShardedState < Int32 > ( \"votes_for\" ); fors . set ( \"Alice\" , increment ( fors . get ( \"Alice\" , 0 ))); // etc. endfunction function increment ( x : Int32 ) : Int32 var y = x + 1 ; return y ; endfunction","title":"Design considerations"},{"location":"smart-contracts/pipenv/","text":"pipenv The wrapper libraries supporting creation and deployment of etch smart contracts are in Python. We therefore advise developing and testing your smart contracts from within a Python environment. Do this with pipenv . Find out about pipenv here , including installation instructions. Once installed, develop and test from within an environment shell. pipenv shell","title":"Python environment"},{"location":"smart-contracts/pipenv/#pipenv","text":"The wrapper libraries supporting creation and deployment of etch smart contracts are in Python. We therefore advise developing and testing your smart contracts from within a Python environment. Do this with pipenv . Find out about pipenv here , including installation instructions. Once installed, develop and test from within an environment shell. pipenv shell","title":"pipenv"},{"location":"smart-contracts/smart-contract-intro/","text":"Introduction to Smart Contracts Quote A smart contract is a computer protocol intended to digitally facilitate, verify, or enforce the negotiation or performance of a contract. Smart contracts allow the performance of credible transactions without third parties. These transactions are trackable and irreversible. Source: Wikipedia . A smart contract facilitates, verifies, and enforces a transaction between two or more parties on a distributed ledger or blockchain. Smart contracts store transactional data on the permanent and irreversible blockchain ledger and, on doing so, change the state of the ledger. Smart contract programming languages are scripting languages specific to the cryptocurrency or platform, such Bitcoin's Script or Ethereum's Solidity. Fetch.AI smart contracts run on the etch virtual machine (VM) which is a logical computation layer used to execute smart contract code. The etch VM and smart contract code reside on every node of the distributed Fetch.AI Ledger. Smart contracts can be used for voting applications, crowdfunding, auctions, multi-signature wallets, identity verification, and much more. etch builds up smart contracts using State and ShardedState data structures, and the Address type which represents account owners and gives access to respective balances. The Ledger Smart contract transactions are etched onto the Fetch.AI distributed ledger, or blockchain, and are therefore permanent, traceable, and irreversible. The Fetch.AI Ledger is the blockchain foundation of the etch VM. Quick start instructions for spinning up a Fetch.AI Ledger node are here . The Fetch.AI Ledger is unlike more traditional blockchain designs. Instead of a single chain of truth, the Fetch.AI Ledger is sharded into parallel lanes. This blockchain sharding design speeds up the network as contracts can execute concurrently. For Fetch.AI Ledger developer documentation, click here . Determinism In computer science, determinism ensures that an input to an algorithm will always produce the same output. When designing etch smart contract code which will execute on Fetch.AI Ledger nodes, it is essential to avoid non-deterministic behaviour that may break consensus. Any code that causes separate nodes to have different values for the same thing may break consensus. Smart contract developers should therefore consider the following: Randomness: along with random functions, non-deterministic randomness can arise in other places, such as Hash Map implementations and Map iterations, for example. Concurrency: multiple processes targeting the same state transactions can break consensus. Ill-considered imports: e.g. libraries containing non-deterministic functions, such as time functions, or APIs that access external and unpredictable systems. Timestamps: watch out for non-deterministic timestamp implementations. Asynchronous behaviour can break consensus. It may be prudent to implement any essential non-deterministic behaviour outside of smart contract ledger code. Fees Fetch.AI charges developers for computation and storage of data on the Fetch.AI Ledger in a manner which incentivises good coding practices. You can limit the fees paid for smart contract execution by distributing data storage over a single shard and a minimum number of shard lanes. Fees rise in a linear manner per number of shards up to the maximum number of shards, after which point the fees increase exponentially. Note Coming soon: details of developer fee structures for smart contract data.","title":"Introduction"},{"location":"smart-contracts/smart-contract-intro/#the-ledger","text":"Smart contract transactions are etched onto the Fetch.AI distributed ledger, or blockchain, and are therefore permanent, traceable, and irreversible. The Fetch.AI Ledger is the blockchain foundation of the etch VM. Quick start instructions for spinning up a Fetch.AI Ledger node are here . The Fetch.AI Ledger is unlike more traditional blockchain designs. Instead of a single chain of truth, the Fetch.AI Ledger is sharded into parallel lanes. This blockchain sharding design speeds up the network as contracts can execute concurrently. For Fetch.AI Ledger developer documentation, click here .","title":"The Ledger"},{"location":"smart-contracts/smart-contract-intro/#determinism","text":"In computer science, determinism ensures that an input to an algorithm will always produce the same output. When designing etch smart contract code which will execute on Fetch.AI Ledger nodes, it is essential to avoid non-deterministic behaviour that may break consensus. Any code that causes separate nodes to have different values for the same thing may break consensus. Smart contract developers should therefore consider the following: Randomness: along with random functions, non-deterministic randomness can arise in other places, such as Hash Map implementations and Map iterations, for example. Concurrency: multiple processes targeting the same state transactions can break consensus. Ill-considered imports: e.g. libraries containing non-deterministic functions, such as time functions, or APIs that access external and unpredictable systems. Timestamps: watch out for non-deterministic timestamp implementations. Asynchronous behaviour can break consensus. It may be prudent to implement any essential non-deterministic behaviour outside of smart contract ledger code.","title":"Determinism"},{"location":"smart-contracts/smart-contract-intro/#fees","text":"Fetch.AI charges developers for computation and storage of data on the Fetch.AI Ledger in a manner which incentivises good coding practices. You can limit the fees paid for smart contract execution by distributing data storage over a single shard and a minimum number of shard lanes. Fees rise in a linear manner per number of shards up to the maximum number of shards, after which point the fees increase exponentially. Note Coming soon: details of developer fee structures for smart contract data.","title":"Fees"},{"location":"smart-contracts/smart-contracts/","text":"Etch smart contracts Smart contract code runs on the etch virtual machine. All ledger nodes contain the etch VM and smart contract code. The identity of a smart contract is calculated by performing a SHA256 hash on the contract code string as an initial step. Next, a further SHA256 hash is calculated from the previous result concatenated with a public key Address which represents the contract owner. On the ledger, the etch VM stores the contract identity, the contract source code, and the data resources that are mapped by a data.json file. With this information, the etch VM performs a modulo 16 calculation to decide where to store the data on the ledger, i.e. onto which shard. Note Coming soon: details on how developers may dictate the sharding storage design for a smart contract. Smart contract structure Smart contract functions are annotated depending on the activity they perform. @init The @init function defines a contract constructor that sets the state of the contract prior to any operations performed on it. It is called once and once only on contract initialisation/deployment. The name of the @init function can be anything at all. For example, the following function initialises a contract by creating a State type to represent the owner's account which then receives an initial supply of FET tokens. This happens once and once only at contract deployment. @ init function initialise ( owner : Address ) var INITIAL_SUPPLY = 100000000000u64 ; var account = State < UInt64 > ( \"owner\" ); account . set ( INITIAL_SUPPLY ); endfunction function main () var owner = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); initialise ( owner ); endfunction Remember We use main() in the examples to allow for testing smart contract code outside of a ledger environment. @action The @action annotation signifies a function which performs a transaction. You cannot create a smart contract in etch without an @action function and it is these functions that trigger the charging rules for data persistence fees. The following function performs a transaction between two parties. @ action function transfer ( from : Address , to : Address , amount : UInt64 ) var from_balance = State < UInt64 > ( from ); from_balance . set ( 1000u64 ); var to_balance = State < UInt64 > ( to ); to_balance . set ( 0u64 ); // check if all the conditions are valid if ( from_balance . get () <= amount ) panic ( \"Argh!\" ); endif from_balance . set ( from_balance . get () - amount ); to_balance . set ( to_balance . get () + amount ); endfunction function main () var owner = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var user = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); transfer ( owner , user , 100u64 ); endfunction In the worst case, the above function needs two shards for data storage. @query Query functions are read-only functions that allow you to view data residing on the ledger. The following function queries the balance of an Address . @ query function balance ( address : Address ) : UInt64 var account = State < UInt64 > ( address ); account . set ( 100u64 ); return account . get (); endfunction function main () var owner = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); var owner_balance = balance ( owner ); printLn ( owner_balance ); endfunction Smart contract addresses etch smart contracts have a unique identification protocol for addressing on the Fetch.AI Ledger. etch smart contract identifiers are a SHA256 hash of the contract source code which is then Base64 encoded and finally concatenated with the Base64 encoded owner's public key. Using this identifier, smart contract functions are accessible with a subsequent . plus function name. Data confirmation If you run an etch contract in the simulator containing one or more State types and flag the compiler with -data and a filename, it will create a json file containing the details of the data that will be stored on the ledger. ./etch *filename* -data data.json If we run one of the above code examples in this way, data.json may contain the following: { \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" : \"8403000000000000\" } Utility functions getBlockNumber() : returns the number of the current block in UInt64 . You need a node running to test this. As well as that, you can only get a result when the function is embedded within smart contract code in Python. See a coded example of getBlockNumber() with a running node here .","title":"Etch smart contracts"},{"location":"smart-contracts/smart-contracts/#smart-contract-structure","text":"Smart contract functions are annotated depending on the activity they perform.","title":"Smart contract structure"},{"location":"smart-contracts/smart-contracts/#smart-contract-addresses","text":"etch smart contracts have a unique identification protocol for addressing on the Fetch.AI Ledger. etch smart contract identifiers are a SHA256 hash of the contract source code which is then Base64 encoded and finally concatenated with the Base64 encoded owner's public key. Using this identifier, smart contract functions are accessible with a subsequent . plus function name.","title":"Smart contract addresses"},{"location":"smart-contracts/smart-contracts/#data-confirmation","text":"If you run an etch contract in the simulator containing one or more State types and flag the compiler with -data and a filename, it will create a json file containing the details of the data that will be stored on the ledger. ./etch *filename* -data data.json If we run one of the above code examples in this way, data.json may contain the following: { \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" : \"8403000000000000\" }","title":"Data confirmation"},{"location":"smart-contracts/smart-contracts/#utility-functions","text":"getBlockNumber() : returns the number of the current block in UInt64 . You need a node running to test this. As well as that, you can only get a result when the function is embedded within smart contract code in Python. See a coded example of getBlockNumber() with a running node here .","title":"Utility functions"},{"location":"smart-contracts/synergetic/","text":"Introduction to synergetic contracts Synergetic contracts are a new type of smart contract which allow miners to use their computational power to solve useful problems and earn a reward. Anyone can register a problem on the ledger by creating a synergetic contract and inviting miners to solve it. All attempts at solving the problem form a Directed Acyclic Graph (DAG). The type of problems that synergetic contracts can solve are complex optimisation problems such as scheduling patient appointments and protein folding . A miner registers as a participant of the synergetic contract and starts calculating towards the problem solution from a random seed generated from a public key. It is a trial and error approach like proof of work. Registered miners begin to solve the problem at the same time and the miner who solves the problem first wins the bounty associated with the problem. Note The winning miner is not necessarily the miner who verifies the block. Annotations etch synergetic contract code includes specific annotated functions. @problem specifies a problem. @objective measures the solution to a given problem. @work creates a solution from a random number/nonce. @clear finishes the competition, zeros everything, and saves the solution.","title":"Synergetic contracts"},{"location":"smart-contracts/synergetic/#annotations","text":"etch synergetic contract code includes specific annotated functions. @problem specifies a problem. @objective measures the solution to a given problem. @work creates a solution from a random number/nonce. @clear finishes the competition, zeros everything, and saves the solution.","title":"Annotations"},{"location":"smart-contracts/wallets/","text":"Fetch.AI wallet The Fetch.AI wallet is available to download on GooglePlay . You can store your test FET here for playing around with on the test network. Fetch testnet To get testnet access, go to the Fetch community site https://community.fetch.ai/ . Click the Get Testnet Access button and login with your GitHub or Google account. Follow the guide to request FET testnet tokens. Fetch public network Note In development.","title":"Wallets"},{"location":"smart-contracts/wallets/#fetchai-wallet","text":"The Fetch.AI wallet is available to download on GooglePlay . You can store your test FET here for playing around with on the test network.","title":"Fetch.AI wallet"},{"location":"smart-contracts/wallets/#fetch-testnet","text":"To get testnet access, go to the Fetch community site https://community.fetch.ai/ . Click the Get Testnet Access button and login with your GitHub or Google account. Follow the guide to request FET testnet tokens.","title":"Fetch testnet"},{"location":"smart-contracts/wallets/#fetch-public-network","text":"Note In development.","title":"Fetch public network"},{"location":"tutorials/block-number/","text":"Run the following Python script and embedded smart contract to test the getBlockNumber() function. You need to run this against a running node on localhost port 8100 . Details for running a node are here . from fetchai . ledger . api import LedgerApi from fetchai . ledger . contract import SmartContract from fetchai . ledger . crypto import Entity , Address CONTRACT_TEXT = \"\"\" @ action function set_block_number_state () State < UInt64 > ( ' block_number_state ' ). set ( getBlockNumber ()); endfunction @ query function query_block_number_state () : UInt64 return State < UInt64 > ( ' block_number_state ' ). get ( 0u64 ); endfunction \"\"\" def main () : entity1 = Entity () # build the ledger API api = LedgerApi ( ' 127.0.0.1 ' , 8100 ) # create wealth so that we have the funds to be able to create contracts on the network api . sync ( api . tokens . wealth ( entity1 , 100000 )) # create the smart contract contract = SmartContract ( CONTRACT_TEXT ) # deploy the contract to the network api . sync ( api . contracts . create ( entity1 , contract , 2000 )) api . sync ( contract . action ( api , ' set_block_number_state ' , 400 , [ entity1 ])) print ( contract . query ( api , ' query_block_number_state ' )) if __name__ == ' __main__ ' : main ()","title":"Get block number"},{"location":"tutorials/erc20/","text":"Create an ERC20 contract The following tutorial assumes that you already have a constellation instance running on port 8100 and that you have installed the the Python API. Details for running a node are here . Details of the Python API are here . Requirements The ERC20 contract implements following functions: totalSupply() : UInt256 gets the total token supply. balanceOf(owner: Address): UInt256 gets the balance of an account having address owner . transfer(to: Address, value: UInt256) : Bool sends value amount of tokens to address to . transferFrom(from: Address, to: Address, value: UInt256): Bool sends value amount of tokens from address from to address to . approve(spender: Address, value: UInt256) : Bool allows spender to withdraw from your account, multiple times, up to the value amount. If this function is called again it overwrites the current allowance with value . allowance(owner: Address, spender: Address) returns the amount which spender is still allowed to withdraw from owner . We now go ahead and implement most of these functions. Note As Fetch.AI smart contracts do not have implicit addresses, as in Ethereum, the function signatures are slightly different, as will see below, but the overall functionality remains the same. Initialisation function We first define the contract constructor function which is annotated with the @init keyword. The @init annotation tells the ledger that the function should be invoked upon initial deployment of the contract: @ init function createSupply ( owner : Address , supply : UInt256 ) var supply_state = State < UInt256 > ( \"total_supply\" ); supply_state . set ( supply ); var balance_state = State < UInt256 > ( owner ); balance_state . set ( supply ); endfunction The transaction that submits the contract to the ledger is responsible for providing the constructor arguments. The above @init function creates a state for the owner issuing supply tokens. Furthermore, for this specific contract we have made the total supply programmable so that the contract can be reused and to facilitate testing. Queries The ERC20 contract has three query functions: totalSupply(): UInt256 . balanceOf(owner: Address) : UInt256 . allowance(owner: Address, spender: Address) : UInt256 . We will define totalSupply and balanceOf in this section and discuss allowance later on. Both totalSupply and balanceOf are straightforward to implement. totalSupply queries the State variable total_supply and returns it as a result: @ query function totalSupply () : UInt256 var supply_state = State < UInt256 > ( \"total_supply\" ); return supply_state . get ( 0u64 ); endfunction balanceOf , on the other hand, does a dynamic look up based on the address of owner : @ query function balanceOf ( owner : Address ) : UInt256 var balance_state = State < UInt256 > ( owner ); if ( ! balance_state . existed ()) return UInt256 ( 0u64 ); endif return balance_state . get ( UInt256 ( 0u64 )); endfunction These two query mechanisms demonstrate two different ways of handling undefined states. In the first query, we request the total_supply by calling get on the state variable and supplying a default value if the state does not exist. In the second query, we manually check whether the variable existed at the beginning of the contract call and if not, we return 0 . Both are valid ways to manage a state existence. Actions The ERC20 contract defines three functions annotated with @action : transfer(from: Address, to: Address, value: UInt256) : Bool . transferFrom(from: Address, to: Address, value: UInt256): Bool . approve(spender: Address, value: UInt256) : Bool . We will discuss approve in the next section. In etch , transfer and transferFrom are one and the same function as etch does not have an implicitly provided sender. Rather from and to are explicit function arguments and whether these addresses signed the transaction is checked within the @action function. @ action function transfer ( from : Address , to : Address , value : UInt256 ) : Bool if ( ! from . signedTx ()) return false ; endif var from_state = State < UInt256 > ( from ); var from_balance = from_state . get ( UInt256 ( 0u64 ) ); if ( from_balance < value ) return false ; endif var to_state = State < UInt256 > ( to ); var to_balance = to_state . get ( UInt256 ( 0u64 ) ); // TODO: Polyfilling due to missing UInt256 functionality var u_from = toUInt64 ( from_balance ); var u_to = toUInt64 ( to_balance ); var u_amount = toUInt64 ( value ); u_from -= u_amount ; u_to += u_amount ; from_balance = UInt256 ( u_from ); to_balance = UInt256 ( u_to ); from_state . set ( from_balance ); to_state . set ( to_balance ); return true ; endfunction The above demonstrates one of the simplest possible token contracts keeping a balance associated with each address and allowing transfers from one address to the other if the address holds sufficient tokens. Implementing allowance So far, the functions we've seen constitute a basic token contract that allows creation of tokens and transfer between participants. A more interesting functionality is the allowance mechanism in the ERC20 contract that gives one address the possibility of spending some amount based on the allowance details. To create this functionality we could use the normal State object by simply defining the object identifiers. However, a more appropriate mechanism for this purpose is the ShardedState which ensures that the payload is assigned to an appropriate shard within the system. Implementing the approve mechanism using the ShardedState is relatively easy as it provides dictionary-like functionality: @ action function approve ( owner : Address , spender : Address , value : UInt256 ) : Bool var state = ShardedState < UInt256 > ( spender ); state . set ( owner , value ); return true ; endfunction The above builds object addresses by concatenating the spender address with the owner address. However, unlike a normal dictionary, ShardedState does not keep a record of which entries exist or not. Such functionality could be added by simply adding another state variable keeping track of owners. We will see an example on a similar type of functionality in the next part of this guide. Finally, implementing a query mechanism is equally straight forward: @ query function allowance ( owner : Address , spender : Address ) : UInt256 var state = ShardedState < UInt256 > ( spender ); return state . get ( owner , UInt256 ( 0u64 )); endfunction The contract provided here obviously still need additional functionality for allowance to be truly useful as we have not implemented any method to actually spend the allowance. You can find the full contract here .","title":"Create FET-20 contract"},{"location":"tutorials/erc20/#create-an-erc20-contract","text":"The following tutorial assumes that you already have a constellation instance running on port 8100 and that you have installed the the Python API. Details for running a node are here . Details of the Python API are here .","title":"Create an ERC20 contract"},{"location":"tutorials/erc20/#requirements","text":"The ERC20 contract implements following functions: totalSupply() : UInt256 gets the total token supply. balanceOf(owner: Address): UInt256 gets the balance of an account having address owner . transfer(to: Address, value: UInt256) : Bool sends value amount of tokens to address to . transferFrom(from: Address, to: Address, value: UInt256): Bool sends value amount of tokens from address from to address to . approve(spender: Address, value: UInt256) : Bool allows spender to withdraw from your account, multiple times, up to the value amount. If this function is called again it overwrites the current allowance with value . allowance(owner: Address, spender: Address) returns the amount which spender is still allowed to withdraw from owner . We now go ahead and implement most of these functions. Note As Fetch.AI smart contracts do not have implicit addresses, as in Ethereum, the function signatures are slightly different, as will see below, but the overall functionality remains the same.","title":"Requirements"},{"location":"tutorials/erc20/#initialisation-function","text":"We first define the contract constructor function which is annotated with the @init keyword. The @init annotation tells the ledger that the function should be invoked upon initial deployment of the contract: @ init function createSupply ( owner : Address , supply : UInt256 ) var supply_state = State < UInt256 > ( \"total_supply\" ); supply_state . set ( supply ); var balance_state = State < UInt256 > ( owner ); balance_state . set ( supply ); endfunction The transaction that submits the contract to the ledger is responsible for providing the constructor arguments. The above @init function creates a state for the owner issuing supply tokens. Furthermore, for this specific contract we have made the total supply programmable so that the contract can be reused and to facilitate testing.","title":"Initialisation function"},{"location":"tutorials/erc20/#queries","text":"The ERC20 contract has three query functions: totalSupply(): UInt256 . balanceOf(owner: Address) : UInt256 . allowance(owner: Address, spender: Address) : UInt256 . We will define totalSupply and balanceOf in this section and discuss allowance later on. Both totalSupply and balanceOf are straightforward to implement. totalSupply queries the State variable total_supply and returns it as a result: @ query function totalSupply () : UInt256 var supply_state = State < UInt256 > ( \"total_supply\" ); return supply_state . get ( 0u64 ); endfunction balanceOf , on the other hand, does a dynamic look up based on the address of owner : @ query function balanceOf ( owner : Address ) : UInt256 var balance_state = State < UInt256 > ( owner ); if ( ! balance_state . existed ()) return UInt256 ( 0u64 ); endif return balance_state . get ( UInt256 ( 0u64 )); endfunction These two query mechanisms demonstrate two different ways of handling undefined states. In the first query, we request the total_supply by calling get on the state variable and supplying a default value if the state does not exist. In the second query, we manually check whether the variable existed at the beginning of the contract call and if not, we return 0 . Both are valid ways to manage a state existence.","title":"Queries"},{"location":"tutorials/erc20/#actions","text":"The ERC20 contract defines three functions annotated with @action : transfer(from: Address, to: Address, value: UInt256) : Bool . transferFrom(from: Address, to: Address, value: UInt256): Bool . approve(spender: Address, value: UInt256) : Bool . We will discuss approve in the next section. In etch , transfer and transferFrom are one and the same function as etch does not have an implicitly provided sender. Rather from and to are explicit function arguments and whether these addresses signed the transaction is checked within the @action function. @ action function transfer ( from : Address , to : Address , value : UInt256 ) : Bool if ( ! from . signedTx ()) return false ; endif var from_state = State < UInt256 > ( from ); var from_balance = from_state . get ( UInt256 ( 0u64 ) ); if ( from_balance < value ) return false ; endif var to_state = State < UInt256 > ( to ); var to_balance = to_state . get ( UInt256 ( 0u64 ) ); // TODO: Polyfilling due to missing UInt256 functionality var u_from = toUInt64 ( from_balance ); var u_to = toUInt64 ( to_balance ); var u_amount = toUInt64 ( value ); u_from -= u_amount ; u_to += u_amount ; from_balance = UInt256 ( u_from ); to_balance = UInt256 ( u_to ); from_state . set ( from_balance ); to_state . set ( to_balance ); return true ; endfunction The above demonstrates one of the simplest possible token contracts keeping a balance associated with each address and allowing transfers from one address to the other if the address holds sufficient tokens.","title":"Actions"},{"location":"tutorials/erc20/#implementing-allowance","text":"So far, the functions we've seen constitute a basic token contract that allows creation of tokens and transfer between participants. A more interesting functionality is the allowance mechanism in the ERC20 contract that gives one address the possibility of spending some amount based on the allowance details. To create this functionality we could use the normal State object by simply defining the object identifiers. However, a more appropriate mechanism for this purpose is the ShardedState which ensures that the payload is assigned to an appropriate shard within the system. Implementing the approve mechanism using the ShardedState is relatively easy as it provides dictionary-like functionality: @ action function approve ( owner : Address , spender : Address , value : UInt256 ) : Bool var state = ShardedState < UInt256 > ( spender ); state . set ( owner , value ); return true ; endfunction The above builds object addresses by concatenating the spender address with the owner address. However, unlike a normal dictionary, ShardedState does not keep a record of which entries exist or not. Such functionality could be added by simply adding another state variable keeping track of owners. We will see an example on a similar type of functionality in the next part of this guide. Finally, implementing a query mechanism is equally straight forward: @ query function allowance ( owner : Address , spender : Address ) : UInt256 var state = ShardedState < UInt256 > ( spender ); return state . get ( owner , UInt256 ( 0u64 )); endfunction The contract provided here obviously still need additional functionality for allowance to be truly useful as we have not implemented any method to actually spend the allowance. You can find the full contract here .","title":"Implementing allowance"},{"location":"tutorials/erc721/","text":"Create an ERC721 contract In this tutorial we are going to implement a subset of the functionality of an ERC721 contract in etch . We will be using UInt256 for identifiers and the SHA256() function to generate the identifiers of the initial tokens. We will need two records: an Address stating which tokens an address holds and a token record keeping track of the owner of the token. For the first of these tasks, we will use the State object in etch , and for the second we will use ShardedState . Initialisation function Assuming that we have defined an owner and a total_supply , the initialise function will do three things: Generate a list of token ids. Create a record of each token owner. Create a record of the tokens that an owner has. The dual relationship makes lookups efficient, but comes at the price of twice the book keeping. First, create the list of token ids: // Genereating tokens var token_id = UInt256 ( \"hello world\" ); for ( i in 0 : tokens . count ()) var hasher = SHA256 (); hasher . update ( token_id ); token_id = hasher . final (); tokens [ i ] = token_id ; endfor Next, assign an owner: // Assigning owner var owner_state = ShardedState < Address > ( \"tokens.owner\" ); for ( i in 0 : tokens . count ()) var tid = tokens [ i ]; owner_state . set ( toString ( tid ), owner ); endfor Finally, store the list of tokens on the creator's address: var objects_state = State < Array < UInt256 > > ( owner ); // Storing the tokens on the owners address objects_state . set ( tokens ); Queries In this section we will focus on the functions which implement a wallet overview and token details view, namely balanceOf(owner: Address) : UInt256 and ownerOf(token_id: UInt256) : Address . Both of these functions are short and easy to implement. First, we make it possible to query the balance: @ query function balanceOf ( owner : Address ) : UInt256 var objects_state = State < Array < UInt256 > > ( owner ); var tokens = objects_state . get ( Array < UInt256 > ( 0 ) ); var ret = UInt256 ( toUInt64 ( tokens . count ()) ); return ret ; endfunction Next, we make it possible to query the token owner: @ query function ownerOf ( token_id : UInt256 ) : Address var owner_state = ShardedState < Address > ( \"tokens.owner\" ); return owner_state . get ( toString ( token_id )); endfunction With these two query functions, it is possible to implement an ERC-721 wallet on top of the smart ledger. We can also make several optimisations for these functions. For instance, by storing the number of tokens separately, we would not have to deserialise the full array. Actions The standard ERC-721 contract has a number of different functions for transferring funds from one party to another. We will implement just one of these; they are all essentially variations of the same mechanism with more or less error checking built into them. Implement a single transfer function: function transferFrom ( from : Address , to : Address , token_id : UInt256 ) if ( ! from . signedTx ()) panic ( \"Invalid signature from owner.\" ); endif var owner_state = ShardedState < Address > ( \"tokens.owner\" ); var owner = owner_state . get ( toString ( token_id )); if ( owner != from ) panic ( \"Owner does not actually own the token\" ); endif var from_state = State < Array < UInt256 > > ( from ); var from_objects = from_state . get ( Array < UInt256 > ( 0 ) ); var found = false ; var position : Int32 ; for ( i in 0 : from_objects . count () - 1 ) var tid = from_objects [ i ]; if ( tid == token_id ) if ( found ) panic ( \"Contract broken - token is only supposed be represented once.\" ); endif found = true ; position = i ; break ; endif endfor if ( ! found ) panic ( \"Contract is fundamentally broken - owner has not been updated correctly\" ); endif from_objects [ position ] = from_objects [ from_objects . count () - 1 ]; from_objects . popBack (); var to_state = State < Array < UInt256 > > ( to ); var to_objects = to_state . get ( Array < UInt256 > ( 0 ) ); to_objects . append ( token_id ); // updating sender from_state . set ( from_objects ); // Updating receiver to_state . set ( to_objects ); // Updating owner owner = to ; owner_state . set ( toString ( token_id ), owner ); endfunction The above implementation requires the sender to sign the transaction, but can be extended to also requiring the receiver to sign as well. The full contract can be found here .","title":"Create FET-721 contract"},{"location":"tutorials/erc721/#create-an-erc721-contract","text":"In this tutorial we are going to implement a subset of the functionality of an ERC721 contract in etch . We will be using UInt256 for identifiers and the SHA256() function to generate the identifiers of the initial tokens. We will need two records: an Address stating which tokens an address holds and a token record keeping track of the owner of the token. For the first of these tasks, we will use the State object in etch , and for the second we will use ShardedState .","title":"Create an ERC721 contract"},{"location":"tutorials/erc721/#initialisation-function","text":"Assuming that we have defined an owner and a total_supply , the initialise function will do three things: Generate a list of token ids. Create a record of each token owner. Create a record of the tokens that an owner has. The dual relationship makes lookups efficient, but comes at the price of twice the book keeping. First, create the list of token ids: // Genereating tokens var token_id = UInt256 ( \"hello world\" ); for ( i in 0 : tokens . count ()) var hasher = SHA256 (); hasher . update ( token_id ); token_id = hasher . final (); tokens [ i ] = token_id ; endfor Next, assign an owner: // Assigning owner var owner_state = ShardedState < Address > ( \"tokens.owner\" ); for ( i in 0 : tokens . count ()) var tid = tokens [ i ]; owner_state . set ( toString ( tid ), owner ); endfor Finally, store the list of tokens on the creator's address: var objects_state = State < Array < UInt256 > > ( owner ); // Storing the tokens on the owners address objects_state . set ( tokens );","title":"Initialisation function"},{"location":"tutorials/erc721/#queries","text":"In this section we will focus on the functions which implement a wallet overview and token details view, namely balanceOf(owner: Address) : UInt256 and ownerOf(token_id: UInt256) : Address . Both of these functions are short and easy to implement. First, we make it possible to query the balance: @ query function balanceOf ( owner : Address ) : UInt256 var objects_state = State < Array < UInt256 > > ( owner ); var tokens = objects_state . get ( Array < UInt256 > ( 0 ) ); var ret = UInt256 ( toUInt64 ( tokens . count ()) ); return ret ; endfunction Next, we make it possible to query the token owner: @ query function ownerOf ( token_id : UInt256 ) : Address var owner_state = ShardedState < Address > ( \"tokens.owner\" ); return owner_state . get ( toString ( token_id )); endfunction With these two query functions, it is possible to implement an ERC-721 wallet on top of the smart ledger. We can also make several optimisations for these functions. For instance, by storing the number of tokens separately, we would not have to deserialise the full array.","title":"Queries"},{"location":"tutorials/erc721/#actions","text":"The standard ERC-721 contract has a number of different functions for transferring funds from one party to another. We will implement just one of these; they are all essentially variations of the same mechanism with more or less error checking built into them. Implement a single transfer function: function transferFrom ( from : Address , to : Address , token_id : UInt256 ) if ( ! from . signedTx ()) panic ( \"Invalid signature from owner.\" ); endif var owner_state = ShardedState < Address > ( \"tokens.owner\" ); var owner = owner_state . get ( toString ( token_id )); if ( owner != from ) panic ( \"Owner does not actually own the token\" ); endif var from_state = State < Array < UInt256 > > ( from ); var from_objects = from_state . get ( Array < UInt256 > ( 0 ) ); var found = false ; var position : Int32 ; for ( i in 0 : from_objects . count () - 1 ) var tid = from_objects [ i ]; if ( tid == token_id ) if ( found ) panic ( \"Contract broken - token is only supposed be represented once.\" ); endif found = true ; position = i ; break ; endif endfor if ( ! found ) panic ( \"Contract is fundamentally broken - owner has not been updated correctly\" ); endif from_objects [ position ] = from_objects [ from_objects . count () - 1 ]; from_objects . popBack (); var to_state = State < Array < UInt256 > > ( to ); var to_objects = to_state . get ( Array < UInt256 > ( 0 ) ); to_objects . append ( token_id ); // updating sender from_state . set ( from_objects ); // Updating receiver to_state . set ( to_objects ); // Updating owner owner = to ; owner_state . set ( toString ( token_id ), owner ); endfunction The above implementation requires the sender to sign the transaction, but can be extended to also requiring the receiver to sign as well. The full contract can be found here .","title":"Actions"},{"location":"tutorials/prediction_agent/","text":"Building a prediction agent TODO: Yet to be written.","title":"Building a prediction agent"},{"location":"tutorials/prediction_agent/#building-a-prediction-agent","text":"TODO: Yet to be written.","title":"Building a prediction agent"},{"location":"tutorials/smart-contract-in-stages/","text":"Smart contract in stages Let's look at the three Python scripts in the contract_in_stages directory in the Python API. To run the code in this demo, you will need a running node. Details are here . Details of the Python API are here . Stage 1 The first script 01_create_private_key.py creates an Entity object and inserts the private key from the private.key file in the same directory. Once this is done, the script gives the Entity 10000 tokens. def main (): print ( 'Creating private key...' ) # create our first private key pair entity1 = Entity () # save the private key to disk with open ( 'private.key' , 'w' ) as private_key_file : entity1 . dump ( private_key_file ) print ( 'Creating private key...complete' ) # build the ledger API api = LedgerApi ( '127.0.0.1' , 8100 ) print ( 'Creating initial balance...' ) # create wealth so that we have the funds to be able to create contracts on the network api . sync ( api . tokens . wealth ( entity1 , 10000 )) print ( 'Creating initial balance...complete' ) Stage 2 In the 02_create_contract.py file, we embed the etch smart contract code into the script as a string. We have an init() function which receives an Address object and sets its balance to 1000000 tokens in a State variable. The transfer() function grabs or creates the State objects from two Address objects. After a check to make sure there are enough funds in the from_account, the from_account transfers the amount to the to_account . The query() function allows you to query the balance of an Address on the ledger via a State construct. @ init function setup ( owner : Address ) var owner_balance = State < UInt64 > ( owner ); owner_balance . set ( 1000000u64 ); endfunction @ action function transfer ( from : Address , to : Address , amount : UInt64 ) // define the accounts var from_account = State < UInt64 > ( from ); var to_account = State < UInt64 > ( to ); // if new sets to 0u // Check if the sender has enough balance to proceed if ( from_account . get () >= amount ) // update the account balances from_account . set ( from_account . get () - amount ); to_account . set ( to_account . get ( 0u64 ) + amount ); endif endfunction @ query function balance ( address : Address ) : UInt64 var account = State < UInt64 > ( address ); return account . get ( 0u64 ); endfunction The Python script loads the private key created in the first step, connects to the running ledger node, and deploys the contract to the ledger paying 2000 tokens to do so and designating entity1 as the owner of the contract. def main (): print ( 'Loading private key...' ) # load up the previously created private key with open ( 'private.key' , 'r' ) as private_key_file : entity1 = Entity . load ( private_key_file ) print ( 'Loading private key...complete' ) # build the ledger API api = LedgerApi ( '127.0.0.1' , 8100 ) # create the smart contract contract = SmartContract ( CONTRACT_TEXT ) print ( 'Deploying contract...' ) # deploy the contract to the network api . sync ( api . contracts . create ( entity1 , contract , 2000 )) print ( 'Deploying contract...complete' ) # save the contract to the disk with open ( 'sample.contract' , 'w' ) as contract_file : contract . dump ( contract_file ) Stage 3 In 03_transfer.py we load up the demo private key and the smart contract file. Note Remember, the smart contract is now on the ledger and can be referenced with the correct hash. We then perform a transfer using the contract code between the owner and a new user we create as entity2 . def main (): # load up the previously created private key with open ( 'private.key' , 'r' ) as private_key_file : entity1 = Entity . load ( private_key_file ) # load up the deployed contract with open ( 'sample.contract' , 'r' ) as contract_file : contract = SmartContract . load ( contract_file ) # for the purposes of this example create a second private key pair to transfer funds to entity2 = Entity () # build the ledger API api = LedgerApi ( '127.0.0.1' , 8100 ) # print the current status of all the tokens print ( '-- BEFORE --' ) print_address_balances ( api , contract , [ entity1 , entity2 ]) # transfer from one to the other using our newly deployed contract tok_transfer_amount = 200 fet_tx_fee = 40 api . sync ( contract . action ( api , 'transfer' , fet_tx_fee , [ entity1 ], Address ( entity1 ), Address ( entity2 ), tok_transfer_amount )) print ( '-- AFTER --' ) print_address_balances ( api , contract , [ entity1 , entity2 ]) You should see a result like this: -- BEFORE -- Address0: 8540 bFET 1000000 TOK Address1: 0 bFET 0 TOK -- AFTER -- Address0: 8508 bFET 999800 TOK Address1: 0 bFET 200 TOK","title":"Smart contract in stages"},{"location":"tutorials/smart-contract-in-stages/#stage-1","text":"The first script 01_create_private_key.py creates an Entity object and inserts the private key from the private.key file in the same directory. Once this is done, the script gives the Entity 10000 tokens. def main (): print ( 'Creating private key...' ) # create our first private key pair entity1 = Entity () # save the private key to disk with open ( 'private.key' , 'w' ) as private_key_file : entity1 . dump ( private_key_file ) print ( 'Creating private key...complete' ) # build the ledger API api = LedgerApi ( '127.0.0.1' , 8100 ) print ( 'Creating initial balance...' ) # create wealth so that we have the funds to be able to create contracts on the network api . sync ( api . tokens . wealth ( entity1 , 10000 )) print ( 'Creating initial balance...complete' )","title":"Stage 1"},{"location":"tutorials/smart-contract-in-stages/#stage-2","text":"In the 02_create_contract.py file, we embed the etch smart contract code into the script as a string. We have an init() function which receives an Address object and sets its balance to 1000000 tokens in a State variable. The transfer() function grabs or creates the State objects from two Address objects. After a check to make sure there are enough funds in the from_account, the from_account transfers the amount to the to_account . The query() function allows you to query the balance of an Address on the ledger via a State construct. @ init function setup ( owner : Address ) var owner_balance = State < UInt64 > ( owner ); owner_balance . set ( 1000000u64 ); endfunction @ action function transfer ( from : Address , to : Address , amount : UInt64 ) // define the accounts var from_account = State < UInt64 > ( from ); var to_account = State < UInt64 > ( to ); // if new sets to 0u // Check if the sender has enough balance to proceed if ( from_account . get () >= amount ) // update the account balances from_account . set ( from_account . get () - amount ); to_account . set ( to_account . get ( 0u64 ) + amount ); endif endfunction @ query function balance ( address : Address ) : UInt64 var account = State < UInt64 > ( address ); return account . get ( 0u64 ); endfunction The Python script loads the private key created in the first step, connects to the running ledger node, and deploys the contract to the ledger paying 2000 tokens to do so and designating entity1 as the owner of the contract. def main (): print ( 'Loading private key...' ) # load up the previously created private key with open ( 'private.key' , 'r' ) as private_key_file : entity1 = Entity . load ( private_key_file ) print ( 'Loading private key...complete' ) # build the ledger API api = LedgerApi ( '127.0.0.1' , 8100 ) # create the smart contract contract = SmartContract ( CONTRACT_TEXT ) print ( 'Deploying contract...' ) # deploy the contract to the network api . sync ( api . contracts . create ( entity1 , contract , 2000 )) print ( 'Deploying contract...complete' ) # save the contract to the disk with open ( 'sample.contract' , 'w' ) as contract_file : contract . dump ( contract_file )","title":"Stage 2"},{"location":"tutorials/smart-contract-in-stages/#stage-3","text":"In 03_transfer.py we load up the demo private key and the smart contract file. Note Remember, the smart contract is now on the ledger and can be referenced with the correct hash. We then perform a transfer using the contract code between the owner and a new user we create as entity2 . def main (): # load up the previously created private key with open ( 'private.key' , 'r' ) as private_key_file : entity1 = Entity . load ( private_key_file ) # load up the deployed contract with open ( 'sample.contract' , 'r' ) as contract_file : contract = SmartContract . load ( contract_file ) # for the purposes of this example create a second private key pair to transfer funds to entity2 = Entity () # build the ledger API api = LedgerApi ( '127.0.0.1' , 8100 ) # print the current status of all the tokens print ( '-- BEFORE --' ) print_address_balances ( api , contract , [ entity1 , entity2 ]) # transfer from one to the other using our newly deployed contract tok_transfer_amount = 200 fet_tx_fee = 40 api . sync ( contract . action ( api , 'transfer' , fet_tx_fee , [ entity1 ], Address ( entity1 ), Address ( entity2 ), tok_transfer_amount )) print ( '-- AFTER --' ) print_address_balances ( api , contract , [ entity1 , entity2 ]) You should see a result like this: -- BEFORE -- Address0: 8540 bFET 1000000 TOK Address1: 0 bFET 0 TOK -- AFTER -- Address0: 8508 bFET 999800 TOK Address1: 0 bFET 200 TOK","title":"Stage 3"},{"location":"tutorials/submitting_contract/","text":"Developing smart contracts Let's develop a simple Hello world contract and submit it to a running local ledger node. You can find the code for this tutorial here . To run the code in this demo, you will need a running node. Details are here . Hello world with etch Our demo smart contract has two functions. The @init function etches the variable name onto the state database. Next, a @query function queries the state database for name . @init function createMessage ( owner : Address ) var name : String = \"world\" ; var state = State < String > ( \"greetings\" ); state . set ( name ); endfunction @query function persistentGreeting () : String var state = State < String > ( \"greetings\" ); return \"Hello, \" + state . get () + \"!\" ; endfunction Let's use the etch simulator for the development process. Details on setting up the etch simulator are here . We need a main function that etch can invoke: @testCase function main () var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); createMessage ( account ); var greeting = persistentGreeting (); if ( greeting != \"Hello, world!\" ) panic ( \"Greeting differed from expected message.\" ); endif printLn ( greeting ); endfunction You can test this contract with the etch executable. Run the following from your build directory: curl https://raw.githubusercontent.com/fetchai/etch-examples/master/01_submitting_contract/hello_world.etch --output hello_world.etch ./apps/etch/etch hello_world.etch This produces an output similar to: F E \u2571 etch v0.4.1-rc3 T C Copyright 2018-2019 (c) Fetch AI Ltd. H Hello, world! main is the default runner function in etch . When submitting the smart contract to the ledger, we do not need the main function as it is inaccessible to the ledger code. Submitting the contract to the ledger To submit the contract to the ledger, we use the Python API. Details for building and installing the Python API are here . The required imports are as follows: from fetchai.ledger.api import LedgerApi from fetchai.ledger.contract import SmartContract from fetchai.ledger.crypto import Entity , Address Next, we embed the smart contract code into the Python script as a string: CONTRACT_TEXT = \"\"\" @init function setup(owner : Address) var owner_balance = State<UInt64>(owner, 0u64); owner_balance.set(1000000u64); endfunction @action function transfer(from: Address, to: Address, amount: UInt64) // define the accounts var from_account = State<UInt64>(from, 0u64); var to_account = State<UInt64>(to, 0u64); // if new sets to 0u // Check if the sender has enough balance to proceed if (from_account.get() >= amount) // update the account balances from_account.set(from_account.get() - amount); to_account.set(to_account.get() + amount); endif endfunction @query function balance(address: Address) : UInt64 var account = State<UInt64>(address, 0u64); return account.get(); endfunction \"\"\" We first create an identity and corresponding address: # Create keypair for the contract owner entity = Entity () address = Address ( entity ) Next, we connect to the running node and generate some wealth in order to be able to pay the fees for programming to the ledger: # Setting API up api = LedgerApi ( '127.0.0.1' , 8100 ) # Need funds to deploy contract api . sync ( api . tokens . wealth ( entity , 100000 )) Finally, we create and submit the contract, paying 10000 gas units in fee: # Create contract contract = SmartContract ( CONTRACT_TEXT ) # Deploy contract api . sync ( api . contracts . create ( entity , contract , 10000 )) After submitting the contract successfully, we can test it with the query function persistentGreeting : # Printing message print ( contract . query ( api , 'persistentGreeting' )) This should produce a Hello world! message.","title":"Hello world smart contract"},{"location":"tutorials/submitting_contract/#developing-smart-contracts","text":"Let's develop a simple Hello world contract and submit it to a running local ledger node. You can find the code for this tutorial here . To run the code in this demo, you will need a running node. Details are here .","title":"Developing smart contracts"},{"location":"tutorials/submitting_contract/#hello-world-with-etch","text":"Our demo smart contract has two functions. The @init function etches the variable name onto the state database. Next, a @query function queries the state database for name . @init function createMessage ( owner : Address ) var name : String = \"world\" ; var state = State < String > ( \"greetings\" ); state . set ( name ); endfunction @query function persistentGreeting () : String var state = State < String > ( \"greetings\" ); return \"Hello, \" + state . get () + \"!\" ; endfunction Let's use the etch simulator for the development process. Details on setting up the etch simulator are here . We need a main function that etch can invoke: @testCase function main () var account = Address ( \"2ifr5dSFRAnXexBMC3HYEVp3JHSuz7KBPXWDRBV4xdFrqGy6R9\" ); createMessage ( account ); var greeting = persistentGreeting (); if ( greeting != \"Hello, world!\" ) panic ( \"Greeting differed from expected message.\" ); endif printLn ( greeting ); endfunction You can test this contract with the etch executable. Run the following from your build directory: curl https://raw.githubusercontent.com/fetchai/etch-examples/master/01_submitting_contract/hello_world.etch --output hello_world.etch ./apps/etch/etch hello_world.etch This produces an output similar to: F E \u2571 etch v0.4.1-rc3 T C Copyright 2018-2019 (c) Fetch AI Ltd. H Hello, world! main is the default runner function in etch . When submitting the smart contract to the ledger, we do not need the main function as it is inaccessible to the ledger code.","title":"Hello world with etch"},{"location":"tutorials/submitting_contract/#submitting-the-contract-to-the-ledger","text":"To submit the contract to the ledger, we use the Python API. Details for building and installing the Python API are here . The required imports are as follows: from fetchai.ledger.api import LedgerApi from fetchai.ledger.contract import SmartContract from fetchai.ledger.crypto import Entity , Address Next, we embed the smart contract code into the Python script as a string: CONTRACT_TEXT = \"\"\" @init function setup(owner : Address) var owner_balance = State<UInt64>(owner, 0u64); owner_balance.set(1000000u64); endfunction @action function transfer(from: Address, to: Address, amount: UInt64) // define the accounts var from_account = State<UInt64>(from, 0u64); var to_account = State<UInt64>(to, 0u64); // if new sets to 0u // Check if the sender has enough balance to proceed if (from_account.get() >= amount) // update the account balances from_account.set(from_account.get() - amount); to_account.set(to_account.get() + amount); endif endfunction @query function balance(address: Address) : UInt64 var account = State<UInt64>(address, 0u64); return account.get(); endfunction \"\"\" We first create an identity and corresponding address: # Create keypair for the contract owner entity = Entity () address = Address ( entity ) Next, we connect to the running node and generate some wealth in order to be able to pay the fees for programming to the ledger: # Setting API up api = LedgerApi ( '127.0.0.1' , 8100 ) # Need funds to deploy contract api . sync ( api . tokens . wealth ( entity , 100000 )) Finally, we create and submit the contract, paying 10000 gas units in fee: # Create contract contract = SmartContract ( CONTRACT_TEXT ) # Deploy contract api . sync ( api . contracts . create ( entity , contract , 10000 )) After submitting the contract successfully, we can test it with the query function persistentGreeting : # Printing message print ( contract . query ( api , 'persistentGreeting' )) This should produce a Hello world! message.","title":"Submitting the contract to the ledger"}]}